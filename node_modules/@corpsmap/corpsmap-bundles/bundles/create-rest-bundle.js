import { createSelector } from 'redux-bundler';

// const config = {
//   name: 'aircraft',
//   uid: 'slug',
//   prefetch: false,
//   routeParam: 'aircraftSlug',
//   getTemplate: '/orgs/:orgSlug/aircraft',
//   putTemplate: '/orgs/:orgSlug/aircraft/:item.slug',
//   postTemplate: '/orgs/:orgSlug/aircraft',
//   deleteTemplate: '/orgs/:orgSlug/aircraft/:item.slug',
//   fetchActions: ['URL_UPDATED', 'AUTH_LOGGED_IN']
// }

const decorateUrlWithItem = (urlTemplate, item) => {
  const regex = /(:.*?)(\/|$)/ig;
  let url = urlTemplate;
  let m;
  while ((m = regex.exec(urlTemplate)) != null){
    if(m.index === regex.lastIndex){
      regex.lastIndex++
    }
    const param = m[1];
    if(param.indexOf('item') !== -1){
      const key = param.split('.')[1];
      url = url.replace(param, item[key]);
    }
  }
  return url;
}

export default (opts) => {

  const defaults = {
    name: null,
    uid: 'id',
    prefetch: false,
    routeParam: null,
    getTemplate: '/',
    putTemplate: '/',
    postTemplate: '/',
    deleteTemplate: '/',
    fetchActions: []
  }

  const config = Object.assign({}, defaults, opts);

  const uCaseName = config.name.charAt(0).toUpperCase() + config.name.slice(1);
  const baseType = config.name.toUpperCase();

  // actions
  const actions = {
    FETCH_STARTED: `${baseType}_FETCH_STARTED`,
    FETCH_FINISHED: `${baseType}_FETCH_FINISHED`,
    SAVE_STARTED: `${baseType}_SAVE_STARTED`,
    SAVE_FINISHED: `${baseType}_SAVE_FINISHED`,
    DELETE_STARTED: `${baseType}_DELETE_STARTED`,
    DELETE_FINISHED: `${baseType}_DELETE_FINISHED`,
    UPDATED_ITEM: `${baseType}_UPDATED_ITEM`,
    ERROR: `${baseType}_ERROR`,
  }

  // action creators
  const doFetch = `do${uCaseName}Fetch`;
  const doSave = `do${uCaseName}Save`;
  const doDelete = `do${uCaseName}Delete`;

  // selectors
  const selectState = `select${uCaseName}State`;
  const selectFlags = `select${uCaseName}Flags`;
  const selectGetUrl = `select${uCaseName}GetUrl`;
  const selectPutUrl = `select${uCaseName}PutUrl`;
  const selectPostUrl = `select${uCaseName}PostUrl`;
  const selectDeleteUrl = `select${uCaseName}DeleteUrl`;
  const selectItemsObject = `select${uCaseName}ItemsObject`;
  const selectItemsArray = `select${uCaseName}ItemsArray`;
  const selectItems = `select${uCaseName}Items`;
  const selectByRoute = `select${uCaseName}ByRoute`;
  const selectIsLoading = `select${uCaseName}IsLoading`;
  const selectIsSaving = `select${uCaseName}IsSaving`;
  const selectFetchCount = `select${uCaseName}FetchCount`;

  // reactors
  const reactShouldFetch = `react${uCaseName}ShouldFetch`;

  return Object.assign(
    {}, 
    {
      name: config.name,

      getReducer: () => {
        const initialData = { 
          _err: null,
          _isSaving: false,
          _isLoading: false,
          _shouldFetch: config.prefetch,
          _fetchCount: 0
        }

        return (state = initialData, { type, payload }) => {

          if(config.fetchActions.indexOf(type) !== -1){
            return Object.assign({}, state, { _shouldFetch: true });
          }

          switch(type){
            case actions.SAVE_STARTED:
            case actions.SAVE_FINISHED:
            case actions.FETCH_STARTED:
            case actions.DELETE_STARTED:
            case actions.DELETE_FINISHED:
            case actions.ERROR:
              return Object.assign({}, state, payload);
            case actions.FETCH_FINISHED:
            case actions.UPDATED_ITEM:
              return Object.assign({}, payload);
            default:
              return state;
          }
        }
      },

      [doFetch]: () => ({ dispatch, store, apiGet }) => {
        dispatch({ 
          type: actions.FETCH_STARTED, 
          payload: { _shouldFetch: false, _isLoading: true } 
        });

        const url = store[selectGetUrl]();
        let fetchCount = store[selectFetchCount]();

        if(url.indexOf('/:') !== -1){
          // if we haven't filled in all of our params then bail
          return;
        }else{
          apiGet(url, (err, response, body) => {
            if(err || response.statusCode !== 200){
              dispatch({ 
                type: actions.ERROR, 
                payload: { 
                  _err: {err: err, response: response},
                  notification: {
                    statusCode: response.statusCode
                  },
                  _isLoading: false, 
                  _fetchCount: ++fetchCount 
                }
              })
            }else{
              const flags = store[selectFlags]();
              const data = JSON.parse(body);
              const itemsById = {};
              data.forEach((item) => {
                itemsById[item[config.uid]] = item;
              })
              dispatch({ 
                type: actions.FETCH_FINISHED, 
                payload: { ...itemsById, ...flags, ...{ _isLoading: false, _fetchCount: ++fetchCount } }
              });
            }
          })
        }
      },

      [doSave]: (item, callback, deferCallback) => ({ dispatch, store, apiPut, apiPost}) => {
        dispatch({ 
          type: actions.SAVE_STARTED,
          payload: {
            _isSaving: true
          }
        });

        // grab the state object
        const tempState = store[selectState]();


        if(!item[config.uid]){

          const url = decorateUrlWithItem(store[selectPostUrl](), item);
          
          // create a temporary id and store it in state using that as the key
          const tempId = Number(new Date()).toString();
          tempState[tempId] = Object.assign({}, item);
          dispatch({ 
            type: actions.UPDATED_ITEM, 
            payload: tempState 
          });

          apiPost(url, item, (err, response, body) => {
            if(err || response.statusCode !== 200){
              dispatch({ 
                type: actions.ERROR, 
                payload: { 
                  _err: {err: err, response: response},
                  notification: {
                    statusCode: response.statusCode
                  }, 
                  _isSaving: false }
              })
            }else{
              // remove our temporary record from the state
              const updatedState = store[selectState]();
              delete updatedState[tempId];

              // add our new id to our item and re-attach to our state
              const data = typeof body === 'string' ? JSON.parse(body)[0] : body[0];
              const updatedItem = Object.assign({}, item, data);
              updatedState[updatedItem[config.uid]] = updatedItem
              
              dispatch({ 
                type: actions.UPDATED_ITEM, 
                payload: updatedState
              });

              // Make sure we're sending save_finished when we're done
              dispatch({ 
                type: actions.SAVE_FINISHED,
                payload: {
                  _isSaving: false
                }
              }); 

              if(deferCallback && callback) callback();
            }
            // if we get a callback, go ahead and fire it
            if(!deferCallback && callback) callback();
          })

        }else{
          const url = decorateUrlWithItem(store[selectPutUrl](), item);

          // add our updated item to the state based on it's key
          tempState[item[config.uid]] = Object.assign({}, item);
          dispatch({ 
            type: actions.UPDATED_ITEM, 
            payload: tempState 
          });

          // save changes to the server
          apiPut(url, item, (err, response, body) => {
            if(err || response.statusCode !== 200){
              dispatch({ 
                type: actions.ERROR, 
                payload: { 
                  _err: {err: err, response: response}, 
                  notification: {
                    statusCode: response.statusCode
                  },
                  _isSaving: false 
                }
              })
            }else{
              // if successful we shouldn't have to do anything else
              dispatch({ 
                type: actions.SAVE_FINISHED,
                payload: {
                  _isSaving: false
                }
              }); 
              if(deferCallback && callback) callback();
            }
            // if we get a callback, go ahead and fire it
            if(!deferCallback && callback) callback();
          })

        }
      },

      [doDelete]: (item, callback, deferCallback) => ({ dispatch, store, apiDelete }) => {
        dispatch({
          type: actions.DELETE_STARTED,
          payload: {
            _isSaving: true
          }
        })

        const url = decorateUrlWithItem(store[selectDeleteUrl](), item);
        
        if(url.indexOf('/:') !== -1){
          // if we haven't filled in all of our params then bail
          return;
        }else{
          // remove the item from our state and update it internally
          const updatedState = store[selectState]();
          delete updatedState[item[config.uid]];
          dispatch({ 
            type: actions.UPDATED_ITEM, 
            payload: updatedState
          });

          // update the state on the server now
          apiDelete(url, null, (err, response, body) => {
            if(err || response.statusCode !== 200){
              dispatch({ 
                type: actions.ERROR, 
                payload: { 
                  _err: {err: err, response: response}, 
                  notification: {
                    statusCode: response.statusCode
                  },
                  _isSaving: false 
                }
              })
            }else{
              dispatch({ 
                type: actions.DELETE_FINISHED ,
                payload: {
                  _isSaving: false
                }
              });
              if(deferCallback && callback) callback();
            }
          })
          
          // if we get a callback, go ahead and fire it
          if(!deferCallback && callback) callback();
        }
      },

      [selectFetchCount]: (state) => {
        return state[config.name]._fetchCount;
      },

      [selectState]: (state) => {
        return state[config.name];
      },

      [selectIsLoading]: (state) => {
        return state[config.name]._isLoading;
      },

      [selectIsSaving]: (state) => {
        return state[config.name]._isSaving;
      },

      [selectFlags]: createSelector(
        selectState,
        (state) => {
          const flags = {};
          Object.keys(state).forEach((key) => {
            if(key[0] === '_') flags[key] = state[key];
          })
          return flags;
        }
      ),

      [selectItemsObject]: createSelector(
        selectState,
        (state) => {
          const items = {};
          Object.keys(state).forEach((key) => {
            if(key[0] !== '_') items[key] = state[key];
          })
          return items;
        }
      ),

      [selectItemsArray]: createSelector(
        selectState,
        (state) => {
          const items = [];
          Object.keys(state).forEach((key) => {
            if(key[0] !== '_') items.push(state[key]);
          })
          return items;
        }
      ),

      [selectItems]: createSelector(
        selectItemsArray,
        (items) => {
          return items;
        }
      ),

      [selectByRoute]: createSelector(
        selectItemsObject,
        'selectRouteParams',
        (items, params) => {
          if(params.hasOwnProperty(config.routeParam)){
            if(items.hasOwnProperty(params[config.routeParam])){
              return items[params[config.routeParam]];
            }else{
              return null;
            }
          }else{  
            return null;
          }
        }
      ),

      [selectGetUrl]: createSelector(
        'selectRouteParams',
        'selectFlightsTabRouterParams',
        'selectOrgsAdditionalParams',
        (params, fTabParams, orgsAdditionalParams) => {
          const availableParams = {...params, ...fTabParams, ...orgsAdditionalParams}
          let url = config.getTemplate;
          Object.keys(availableParams).forEach((key) => {
            url = url.replace(`:${key}`, availableParams[key]);
          })
          return url;
        }
      ),

      [selectPutUrl]: createSelector(
        'selectRouteParams',
        'selectFlightsTabRouterParams',
        'selectOrgsAdditionalParams',
        (params, fTabParams, orgsAdditionalParams) => {
          let url = config.putTemplate;
          Object.keys({...params, ...fTabParams, ...orgsAdditionalParams}).forEach((key) => {
            url = url.replace(`:${key}`, params[key]);
          })
          return url;
        }
      ),

      [selectPostUrl]: createSelector(
        'selectRouteParams',
        'selectFlightsTabRouterParams',
        'selectOrgsAdditionalParams',
        (params, fTabParams, orgsAdditionalParams) => {
          let url = config.postTemplate;
          Object.keys({...params, ...fTabParams, ...orgsAdditionalParams}).forEach((key) => {
            url = url.replace(`:${key}`, params[key]);
          })
          return url;
        }
      ),

      [selectDeleteUrl]: createSelector(
        'selectRouteParams',
        'selectFlightsTabRouterParams',
        'selectOrgsAdditionalParams',
        (params, fTabParams, orgsAdditionalParams) => {
          let url = config.deleteTemplate;
          Object.keys({...params, ...fTabParams, ...orgsAdditionalParams}).forEach((key) => {
            url = url.replace(`:${key}`, params[key]);
          })
          return url;
        }
      ),

      [reactShouldFetch]: (state) => {
        if(state[config.name]._shouldFetch) return { actionCreator: doFetch };
      }

    }, 
    config.addons
  )
}