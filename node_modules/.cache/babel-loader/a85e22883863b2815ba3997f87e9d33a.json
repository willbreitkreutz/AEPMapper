{"ast":null,"code":"/**\n * @module ol/render/canvas/LineStringReplay\n */\nimport CanvasInstruction, { strokeInstruction, beginPathInstruction } from './Instruction.js';\nimport CanvasReplay from './Replay.js';\n\nvar CanvasLineStringReplay =\n/*@__PURE__*/\nfunction (CanvasReplay) {\n  function CanvasLineStringReplay(tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree) {\n    CanvasReplay.call(this, tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree);\n  }\n\n  if (CanvasReplay) CanvasLineStringReplay.__proto__ = CanvasReplay;\n  CanvasLineStringReplay.prototype = Object.create(CanvasReplay && CanvasReplay.prototype);\n  CanvasLineStringReplay.prototype.constructor = CanvasLineStringReplay;\n  /**\n   * @param {Array<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {number} end End.\n   * @param {number} stride Stride.\n   * @private\n   * @return {number} end.\n   */\n\n  CanvasLineStringReplay.prototype.drawFlatCoordinates_ = function drawFlatCoordinates_(flatCoordinates, offset, end, stride) {\n    var myBegin = this.coordinates.length;\n    var myEnd = this.appendFlatCoordinates(flatCoordinates, offset, end, stride, false, false);\n    var moveToLineToInstruction = [CanvasInstruction.MOVE_TO_LINE_TO, myBegin, myEnd];\n    this.instructions.push(moveToLineToInstruction);\n    this.hitDetectionInstructions.push(moveToLineToInstruction);\n    return end;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  CanvasLineStringReplay.prototype.drawLineString = function drawLineString(lineStringGeometry, feature) {\n    var state = this.state;\n    var strokeStyle = state.strokeStyle;\n    var lineWidth = state.lineWidth;\n\n    if (strokeStyle === undefined || lineWidth === undefined) {\n      return;\n    }\n\n    this.updateStrokeStyle(state, this.applyStroke);\n    this.beginGeometry(lineStringGeometry, feature);\n    this.hitDetectionInstructions.push([CanvasInstruction.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset], beginPathInstruction);\n    var flatCoordinates = lineStringGeometry.getFlatCoordinates();\n    var stride = lineStringGeometry.getStride();\n    this.drawFlatCoordinates_(flatCoordinates, 0, flatCoordinates.length, stride);\n    this.hitDetectionInstructions.push(strokeInstruction);\n    this.endGeometry(lineStringGeometry, feature);\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  CanvasLineStringReplay.prototype.drawMultiLineString = function drawMultiLineString(multiLineStringGeometry, feature) {\n    var state = this.state;\n    var strokeStyle = state.strokeStyle;\n    var lineWidth = state.lineWidth;\n\n    if (strokeStyle === undefined || lineWidth === undefined) {\n      return;\n    }\n\n    this.updateStrokeStyle(state, this.applyStroke);\n    this.beginGeometry(multiLineStringGeometry, feature);\n    this.hitDetectionInstructions.push([CanvasInstruction.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset], beginPathInstruction);\n    var ends = multiLineStringGeometry.getEnds();\n    var flatCoordinates = multiLineStringGeometry.getFlatCoordinates();\n    var stride = multiLineStringGeometry.getStride();\n    var offset = 0;\n\n    for (var i = 0, ii = ends.length; i < ii; ++i) {\n      offset = this.drawFlatCoordinates_(flatCoordinates, offset, ends[i], stride);\n    }\n\n    this.hitDetectionInstructions.push(strokeInstruction);\n    this.endGeometry(multiLineStringGeometry, feature);\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  CanvasLineStringReplay.prototype.finish = function finish() {\n    var state = this.state;\n\n    if (state.lastStroke != undefined && state.lastStroke != this.coordinates.length) {\n      this.instructions.push(strokeInstruction);\n    }\n\n    this.reverseHitDetectionInstructions();\n    this.state = null;\n  };\n  /**\n   * @inheritDoc.\n   */\n\n\n  CanvasLineStringReplay.prototype.applyStroke = function applyStroke(state) {\n    if (state.lastStroke != undefined && state.lastStroke != this.coordinates.length) {\n      this.instructions.push(strokeInstruction);\n      state.lastStroke = this.coordinates.length;\n    }\n\n    state.lastStroke = 0;\n    CanvasReplay.prototype.applyStroke.call(this, state);\n    this.instructions.push(beginPathInstruction);\n  };\n\n  return CanvasLineStringReplay;\n}(CanvasReplay);\n\nexport default CanvasLineStringReplay;","map":null,"metadata":{},"sourceType":"module"}