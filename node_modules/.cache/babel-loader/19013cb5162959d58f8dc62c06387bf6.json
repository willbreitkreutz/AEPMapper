{"ast":null,"code":"/**\n * @module ol/reproj/Image\n */\nimport { ERROR_THRESHOLD } from './common.js';\nimport ImageBase from '../ImageBase.js';\nimport ImageState from '../ImageState.js';\nimport { listen, unlistenByKey } from '../events.js';\nimport EventType from '../events/EventType.js';\nimport { getCenter, getIntersection, getHeight, getWidth } from '../extent.js';\nimport { calculateSourceResolution, render as renderReprojected } from '../reproj.js';\nimport Triangulation from './Triangulation.js';\n/**\n * @typedef {function(import(\"../extent.js\").Extent, number, number) : import(\"../ImageBase.js\").default} FunctionType\n */\n\n/**\n * @classdesc\n * Class encapsulating single reprojected image.\n * See {@link module:ol/source/Image~ImageSource}.\n */\n\nvar ReprojImage =\n/*@__PURE__*/\nfunction (ImageBase) {\n  function ReprojImage(sourceProj, targetProj, targetExtent, targetResolution, pixelRatio, getImageFunction) {\n    var maxSourceExtent = sourceProj.getExtent();\n    var maxTargetExtent = targetProj.getExtent();\n    var limitedTargetExtent = maxTargetExtent ? getIntersection(targetExtent, maxTargetExtent) : targetExtent;\n    var targetCenter = getCenter(limitedTargetExtent);\n    var sourceResolution = calculateSourceResolution(sourceProj, targetProj, targetCenter, targetResolution);\n    var errorThresholdInPixels = ERROR_THRESHOLD;\n    var triangulation = new Triangulation(sourceProj, targetProj, limitedTargetExtent, maxSourceExtent, sourceResolution * errorThresholdInPixels);\n    var sourceExtent = triangulation.calculateSourceExtent();\n    var sourceImage = getImageFunction(sourceExtent, sourceResolution, pixelRatio);\n    var state = ImageState.LOADED;\n\n    if (sourceImage) {\n      state = ImageState.IDLE;\n    }\n\n    var sourcePixelRatio = sourceImage ? sourceImage.getPixelRatio() : 1;\n    ImageBase.call(this, targetExtent, targetResolution, sourcePixelRatio, state);\n    /**\n     * @private\n     * @type {import(\"../proj/Projection.js\").default}\n     */\n\n    this.targetProj_ = targetProj;\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n\n    this.maxSourceExtent_ = maxSourceExtent;\n    /**\n     * @private\n     * @type {!import(\"./Triangulation.js\").default}\n     */\n\n    this.triangulation_ = triangulation;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.targetResolution_ = targetResolution;\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n\n    this.targetExtent_ = targetExtent;\n    /**\n     * @private\n     * @type {import(\"../ImageBase.js\").default}\n     */\n\n    this.sourceImage_ = sourceImage;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.sourcePixelRatio_ = sourcePixelRatio;\n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n\n    this.canvas_ = null;\n    /**\n     * @private\n     * @type {?import(\"../events.js\").EventsKey}\n     */\n\n    this.sourceListenerKey_ = null;\n  }\n\n  if (ImageBase) ReprojImage.__proto__ = ImageBase;\n  ReprojImage.prototype = Object.create(ImageBase && ImageBase.prototype);\n  ReprojImage.prototype.constructor = ReprojImage;\n  /**\n   * @inheritDoc\n   */\n\n  ReprojImage.prototype.disposeInternal = function disposeInternal() {\n    if (this.state == ImageState.LOADING) {\n      this.unlistenSource_();\n    }\n\n    ImageBase.prototype.disposeInternal.call(this);\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  ReprojImage.prototype.getImage = function getImage() {\n    return this.canvas_;\n  };\n  /**\n   * @return {import(\"../proj/Projection.js\").default} Projection.\n   */\n\n\n  ReprojImage.prototype.getProjection = function getProjection() {\n    return this.targetProj_;\n  };\n  /**\n   * @private\n   */\n\n\n  ReprojImage.prototype.reproject_ = function reproject_() {\n    var sourceState = this.sourceImage_.getState();\n\n    if (sourceState == ImageState.LOADED) {\n      var width = getWidth(this.targetExtent_) / this.targetResolution_;\n      var height = getHeight(this.targetExtent_) / this.targetResolution_;\n      this.canvas_ = renderReprojected(width, height, this.sourcePixelRatio_, this.sourceImage_.getResolution(), this.maxSourceExtent_, this.targetResolution_, this.targetExtent_, this.triangulation_, [{\n        extent: this.sourceImage_.getExtent(),\n        image: this.sourceImage_.getImage()\n      }], 0);\n    }\n\n    this.state = sourceState;\n    this.changed();\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  ReprojImage.prototype.load = function load() {\n    if (this.state == ImageState.IDLE) {\n      this.state = ImageState.LOADING;\n      this.changed();\n      var sourceState = this.sourceImage_.getState();\n\n      if (sourceState == ImageState.LOADED || sourceState == ImageState.ERROR) {\n        this.reproject_();\n      } else {\n        this.sourceListenerKey_ = listen(this.sourceImage_, EventType.CHANGE, function (e) {\n          var sourceState = this.sourceImage_.getState();\n\n          if (sourceState == ImageState.LOADED || sourceState == ImageState.ERROR) {\n            this.unlistenSource_();\n            this.reproject_();\n          }\n        }, this);\n        this.sourceImage_.load();\n      }\n    }\n  };\n  /**\n   * @private\n   */\n\n\n  ReprojImage.prototype.unlistenSource_ = function unlistenSource_() {\n    unlistenByKey(\n    /** @type {!import(\"../events.js\").EventsKey} */\n    this.sourceListenerKey_);\n    this.sourceListenerKey_ = null;\n  };\n\n  return ReprojImage;\n}(ImageBase);\n\nexport default ReprojImage;","map":null,"metadata":{},"sourceType":"module"}