{"ast":null,"code":"/**\n * @module ol/format/EsriJSON\n */\nimport Feature from '../Feature.js';\nimport { assert } from '../asserts.js';\nimport { containsExtent } from '../extent.js';\nimport { transformWithOptions } from './Feature.js';\nimport JSONFeature from './JSONFeature.js';\nimport GeometryLayout from '../geom/GeometryLayout.js';\nimport GeometryType from '../geom/GeometryType.js';\nimport LineString from '../geom/LineString.js';\nimport LinearRing from '../geom/LinearRing.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPoint from '../geom/MultiPoint.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Point from '../geom/Point.js';\nimport Polygon from '../geom/Polygon.js';\nimport { deflateCoordinates } from '../geom/flat/deflate.js';\nimport { linearRingIsClockwise } from '../geom/flat/orient.js';\nimport { isEmpty } from '../obj.js';\nimport { get as getProjection } from '../proj.js';\n/**\n * @typedef {import(\"arcgis-rest-api\").Feature} EsriJSONFeature\n * @typedef {import(\"arcgis-rest-api\").FeatureSet} EsriJSONFeatureSet\n * @typedef {import(\"arcgis-rest-api\").Geometry} EsriJSONGeometry\n * @typedef {import(\"arcgis-rest-api\").Point} EsriJSONPoint\n * @typedef {import(\"arcgis-rest-api\").Polyline} EsriJSONPolyline\n * @typedef {import(\"arcgis-rest-api\").Polygon} EsriJSONPolygon\n * @typedef {import(\"arcgis-rest-api\").Multipoint} EsriJSONMultipoint\n * @typedef {import(\"arcgis-rest-api\").HasZM} EsriJSONHasZM\n * @typedef {import(\"arcgis-rest-api\").Position} EsriJSONPosition\n * @typedef {import(\"arcgis-rest-api\").SpatialReferenceWkid} EsriJSONSpatialReferenceWkid\n */\n\n/**\n * @typedef {Object} EsriJSONMultiPolygon\n * @property {Array<Array<Array<Array<number>>>>} rings Rings for the MultiPolygon.\n * @property {boolean} [hasM] If the polygon coordinates have an M value.\n * @property {boolean} [hasZ] If the polygon coordinates have a Z value.\n * @property {EsriJSONSpatialReferenceWkid} [spatialReference] The coordinate reference system.\n */\n\n/**\n * @const\n * @type {Object<import(\"../geom/GeometryType.js\").default, function(EsriJSONGeometry): import(\"../geom/Geometry.js\").default>}\n */\n\nvar GEOMETRY_READERS = {};\nGEOMETRY_READERS[GeometryType.POINT] = readPointGeometry;\nGEOMETRY_READERS[GeometryType.LINE_STRING] = readLineStringGeometry;\nGEOMETRY_READERS[GeometryType.POLYGON] = readPolygonGeometry;\nGEOMETRY_READERS[GeometryType.MULTI_POINT] = readMultiPointGeometry;\nGEOMETRY_READERS[GeometryType.MULTI_LINE_STRING] = readMultiLineStringGeometry;\nGEOMETRY_READERS[GeometryType.MULTI_POLYGON] = readMultiPolygonGeometry;\n/**\n * @const\n * @type {Object<string, function(import(\"../geom/Geometry.js\").default, import(\"./Feature.js\").WriteOptions=): (EsriJSONGeometry)>}\n */\n\nvar GEOMETRY_WRITERS = {};\nGEOMETRY_WRITERS[GeometryType.POINT] = writePointGeometry;\nGEOMETRY_WRITERS[GeometryType.LINE_STRING] = writeLineStringGeometry;\nGEOMETRY_WRITERS[GeometryType.POLYGON] = writePolygonGeometry;\nGEOMETRY_WRITERS[GeometryType.MULTI_POINT] = writeMultiPointGeometry;\nGEOMETRY_WRITERS[GeometryType.MULTI_LINE_STRING] = writeMultiLineStringGeometry;\nGEOMETRY_WRITERS[GeometryType.MULTI_POLYGON] = writeMultiPolygonGeometry;\n/**\n * @typedef {Object} Options\n * @property {string} [geometryName] Geometry name to use when creating features.\n */\n\n/**\n * @classdesc\n * Feature format for reading and writing data in the EsriJSON format.\n *\n * @api\n */\n\nvar EsriJSON =\n/*@__PURE__*/\nfunction (JSONFeature) {\n  function EsriJSON(opt_options) {\n    var options = opt_options ? opt_options : {};\n    JSONFeature.call(this);\n    /**\n     * Name of the geometry attribute for features.\n     * @type {string|undefined}\n     * @private\n     */\n\n    this.geometryName_ = options.geometryName;\n  }\n\n  if (JSONFeature) EsriJSON.__proto__ = JSONFeature;\n  EsriJSON.prototype = Object.create(JSONFeature && JSONFeature.prototype);\n  EsriJSON.prototype.constructor = EsriJSON;\n  /**\n   * @inheritDoc\n   */\n\n  EsriJSON.prototype.readFeatureFromObject = function readFeatureFromObject(object, opt_options) {\n    var esriJSONFeature =\n    /** @type {EsriJSONFeature} */\n    object;\n    var geometry = readGeometry(esriJSONFeature.geometry, opt_options);\n    var feature = new Feature();\n\n    if (this.geometryName_) {\n      feature.setGeometryName(this.geometryName_);\n    }\n\n    feature.setGeometry(geometry);\n\n    if (opt_options && opt_options.idField && esriJSONFeature.attributes[opt_options.idField]) {\n      feature.setId(\n      /** @type {number} */\n      esriJSONFeature.attributes[opt_options.idField]);\n    }\n\n    if (esriJSONFeature.attributes) {\n      feature.setProperties(esriJSONFeature.attributes);\n    }\n\n    return feature;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  EsriJSON.prototype.readFeaturesFromObject = function readFeaturesFromObject(object, opt_options) {\n    var options = opt_options ? opt_options : {};\n\n    if (object['features']) {\n      var esriJSONFeatureSet =\n      /** @type {EsriJSONFeatureSet} */\n      object;\n      /** @type {Array<import(\"../Feature.js\").default>} */\n\n      var features = [];\n      var esriJSONFeatures = esriJSONFeatureSet.features;\n      options.idField = object.objectIdFieldName;\n\n      for (var i = 0, ii = esriJSONFeatures.length; i < ii; ++i) {\n        features.push(this.readFeatureFromObject(esriJSONFeatures[i], options));\n      }\n\n      return features;\n    } else {\n      return [this.readFeatureFromObject(object, options)];\n    }\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  EsriJSON.prototype.readGeometryFromObject = function readGeometryFromObject(object, opt_options) {\n    return readGeometry(\n    /** @type {EsriJSONGeometry} */\n    object, opt_options);\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  EsriJSON.prototype.readProjectionFromObject = function readProjectionFromObject(object) {\n    if (object['spatialReference'] && object['spatialReference']['wkid'] !== undefined) {\n      var spatialReference =\n      /** @type {EsriJSONSpatialReferenceWkid} */\n      object['spatialReference'];\n      var crs = spatialReference.wkid;\n      return getProjection('EPSG:' + crs);\n    } else {\n      return null;\n    }\n  };\n  /**\n   * Encode a geometry as a EsriJSON object.\n   *\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n   * @param {import(\"./Feature.js\").WriteOptions=} opt_options Write options.\n   * @return {EsriJSONGeometry} Object.\n   * @override\n   * @api\n   */\n\n\n  EsriJSON.prototype.writeGeometryObject = function writeGeometryObject(geometry, opt_options) {\n    return writeGeometry(geometry, this.adaptOptions(opt_options));\n  };\n  /**\n   * Encode a feature as a esriJSON Feature object.\n   *\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {import(\"./Feature.js\").WriteOptions=} opt_options Write options.\n   * @return {Object} Object.\n   * @override\n   * @api\n   */\n\n\n  EsriJSON.prototype.writeFeatureObject = function writeFeatureObject(feature, opt_options) {\n    opt_options = this.adaptOptions(opt_options);\n    var object = {};\n    var geometry = feature.getGeometry();\n\n    if (geometry) {\n      object['geometry'] = writeGeometry(geometry, opt_options);\n\n      if (opt_options && opt_options.featureProjection) {\n        object['geometry']['spatialReference'] =\n        /** @type {EsriJSONSpatialReferenceWkid} */\n        {\n          wkid: Number(getProjection(opt_options.featureProjection).getCode().split(':').pop())\n        };\n      }\n    }\n\n    var properties = feature.getProperties();\n    delete properties[feature.getGeometryName()];\n\n    if (!isEmpty(properties)) {\n      object['attributes'] = properties;\n    } else {\n      object['attributes'] = {};\n    }\n\n    return object;\n  };\n  /**\n   * Encode an array of features as a EsriJSON object.\n   *\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\n   * @param {import(\"./Feature.js\").WriteOptions=} opt_options Write options.\n   * @return {Object} EsriJSON Object.\n   * @override\n   * @api\n   */\n\n\n  EsriJSON.prototype.writeFeaturesObject = function writeFeaturesObject(features, opt_options) {\n    opt_options = this.adaptOptions(opt_options);\n    var objects = [];\n\n    for (var i = 0, ii = features.length; i < ii; ++i) {\n      objects.push(this.writeFeatureObject(features[i], opt_options));\n    }\n\n    return (\n      /** @type {EsriJSONFeatureSet} */\n      {\n        'features': objects\n      }\n    );\n  };\n\n  return EsriJSON;\n}(JSONFeature);\n/**\n * @param {EsriJSONGeometry} object Object.\n * @param {import(\"./Feature.js\").ReadOptions=} opt_options Read options.\n * @return {import(\"../geom/Geometry.js\").default} Geometry.\n */\n\n\nfunction readGeometry(object, opt_options) {\n  if (!object) {\n    return null;\n  }\n  /** @type {import(\"../geom/GeometryType.js\").default} */\n\n\n  var type;\n\n  if (typeof object['x'] === 'number' && typeof object['y'] === 'number') {\n    type = GeometryType.POINT;\n  } else if (object['points']) {\n    type = GeometryType.MULTI_POINT;\n  } else if (object['paths']) {\n    var esriJSONPolyline =\n    /** @type {EsriJSONPolyline} */\n    object;\n\n    if (esriJSONPolyline.paths.length === 1) {\n      type = GeometryType.LINE_STRING;\n    } else {\n      type = GeometryType.MULTI_LINE_STRING;\n    }\n  } else if (object['rings']) {\n    var esriJSONPolygon =\n    /** @type {EsriJSONPolygon} */\n    object;\n    var layout = getGeometryLayout(esriJSONPolygon);\n    var rings = convertRings(esriJSONPolygon.rings, layout);\n\n    if (rings.length === 1) {\n      type = GeometryType.POLYGON;\n      object['rings'] = rings[0];\n    } else {\n      type = GeometryType.MULTI_POLYGON;\n      object['rings'] = rings;\n    }\n  }\n\n  var geometryReader = GEOMETRY_READERS[type];\n  return (\n    /** @type {import(\"../geom/Geometry.js\").default} */\n    transformWithOptions(geometryReader(object), false, opt_options)\n  );\n}\n/**\n * Determines inner and outer rings.\n * Checks if any polygons in this array contain any other polygons in this\n * array. It is used for checking for holes.\n * Logic inspired by: https://github.com/Esri/terraformer-arcgis-parser\n * @param {Array<!Array<!Array<number>>>} rings Rings.\n * @param {import(\"../geom/GeometryLayout.js\").default} layout Geometry layout.\n * @return {Array<!Array<!Array<!Array<number>>>>} Transformed rings.\n */\n\n\nfunction convertRings(rings, layout) {\n  var flatRing = [];\n  var outerRings = [];\n  var holes = [];\n  var i, ii;\n\n  for (i = 0, ii = rings.length; i < ii; ++i) {\n    flatRing.length = 0;\n    deflateCoordinates(flatRing, 0, rings[i], layout.length); // is this ring an outer ring? is it clockwise?\n\n    var clockwise = linearRingIsClockwise(flatRing, 0, flatRing.length, layout.length);\n\n    if (clockwise) {\n      outerRings.push([rings[i]]);\n    } else {\n      holes.push(rings[i]);\n    }\n  }\n\n  while (holes.length) {\n    var hole = holes.shift();\n    var matched = false; // loop over all outer rings and see if they contain our hole.\n\n    for (i = outerRings.length - 1; i >= 0; i--) {\n      var outerRing = outerRings[i][0];\n      var containsHole = containsExtent(new LinearRing(outerRing).getExtent(), new LinearRing(hole).getExtent());\n\n      if (containsHole) {\n        // the hole is contained push it into our polygon\n        outerRings[i].push(hole);\n        matched = true;\n        break;\n      }\n    }\n\n    if (!matched) {\n      // no outer rings contain this hole turn it into and outer\n      // ring (reverse it)\n      outerRings.push([hole.reverse()]);\n    }\n  }\n\n  return outerRings;\n}\n/**\n * @param {EsriJSONPoint} object Object.\n * @return {import(\"../geom/Geometry.js\").default} Point.\n */\n\n\nfunction readPointGeometry(object) {\n  var point;\n\n  if (object.m !== undefined && object.z !== undefined) {\n    point = new Point([object.x, object.y, object.z, object.m], GeometryLayout.XYZM);\n  } else if (object.z !== undefined) {\n    point = new Point([object.x, object.y, object.z], GeometryLayout.XYZ);\n  } else if (object.m !== undefined) {\n    point = new Point([object.x, object.y, object.m], GeometryLayout.XYM);\n  } else {\n    point = new Point([object.x, object.y]);\n  }\n\n  return point;\n}\n/**\n * @param {EsriJSONPolyline} object Object.\n * @return {import(\"../geom/Geometry.js\").default} LineString.\n */\n\n\nfunction readLineStringGeometry(object) {\n  var layout = getGeometryLayout(object);\n  return new LineString(object.paths[0], layout);\n}\n/**\n * @param {EsriJSONPolyline} object Object.\n * @return {import(\"../geom/Geometry.js\").default} MultiLineString.\n */\n\n\nfunction readMultiLineStringGeometry(object) {\n  var layout = getGeometryLayout(object);\n  return new MultiLineString(object.paths, layout);\n}\n/**\n * @param {EsriJSONHasZM} object Object.\n * @return {import(\"../geom/GeometryLayout.js\").default} The geometry layout to use.\n */\n\n\nfunction getGeometryLayout(object) {\n  var layout = GeometryLayout.XY;\n\n  if (object.hasZ === true && object.hasM === true) {\n    layout = GeometryLayout.XYZM;\n  } else if (object.hasZ === true) {\n    layout = GeometryLayout.XYZ;\n  } else if (object.hasM === true) {\n    layout = GeometryLayout.XYM;\n  }\n\n  return layout;\n}\n/**\n * @param {EsriJSONMultipoint} object Object.\n * @return {import(\"../geom/Geometry.js\").default} MultiPoint.\n */\n\n\nfunction readMultiPointGeometry(object) {\n  var layout = getGeometryLayout(object);\n  return new MultiPoint(object.points, layout);\n}\n/**\n * @param {EsriJSONMultiPolygon} object Object.\n * @return {import(\"../geom/Geometry.js\").default} MultiPolygon.\n */\n\n\nfunction readMultiPolygonGeometry(object) {\n  var layout = getGeometryLayout(object);\n  return new MultiPolygon(object.rings, layout);\n}\n/**\n * @param {EsriJSONPolygon} object Object.\n * @return {import(\"../geom/Geometry.js\").default} Polygon.\n */\n\n\nfunction readPolygonGeometry(object) {\n  var layout = getGeometryLayout(object);\n  return new Polygon(object.rings, layout);\n}\n/**\n * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n * @param {import(\"./Feature.js\").WriteOptions=} opt_options Write options.\n * @return {EsriJSONGeometry} EsriJSON geometry.\n */\n\n\nfunction writePointGeometry(geometry, opt_options) {\n  var coordinates =\n  /** @type {import(\"../geom/Point.js\").default} */\n  geometry.getCoordinates();\n  var esriJSON;\n  var layout =\n  /** @type {import(\"../geom/Point.js\").default} */\n  geometry.getLayout();\n\n  if (layout === GeometryLayout.XYZ) {\n    esriJSON =\n    /** @type {EsriJSONPoint} */\n    {\n      x: coordinates[0],\n      y: coordinates[1],\n      z: coordinates[2]\n    };\n  } else if (layout === GeometryLayout.XYM) {\n    esriJSON =\n    /** @type {EsriJSONPoint} */\n    {\n      x: coordinates[0],\n      y: coordinates[1],\n      m: coordinates[2]\n    };\n  } else if (layout === GeometryLayout.XYZM) {\n    esriJSON =\n    /** @type {EsriJSONPoint} */\n    {\n      x: coordinates[0],\n      y: coordinates[1],\n      z: coordinates[2],\n      m: coordinates[3]\n    };\n  } else if (layout === GeometryLayout.XY) {\n    esriJSON =\n    /** @type {EsriJSONPoint} */\n    {\n      x: coordinates[0],\n      y: coordinates[1]\n    };\n  } else {\n    assert(false, 34); // Invalid geometry layout\n  }\n\n  return (\n    /** @type {EsriJSONGeometry} */\n    esriJSON\n  );\n}\n/**\n * @param {import(\"../geom/SimpleGeometry.js\").default} geometry Geometry.\n * @return {Object} Object with boolean hasZ and hasM keys.\n */\n\n\nfunction getHasZM(geometry) {\n  var layout = geometry.getLayout();\n  return {\n    hasZ: layout === GeometryLayout.XYZ || layout === GeometryLayout.XYZM,\n    hasM: layout === GeometryLayout.XYM || layout === GeometryLayout.XYZM\n  };\n}\n/**\n * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n * @param {import(\"./Feature.js\").WriteOptions=} opt_options Write options.\n * @return {EsriJSONPolyline} EsriJSON geometry.\n */\n\n\nfunction writeLineStringGeometry(geometry, opt_options) {\n  var lineString =\n  /** @type {import(\"../geom/LineString.js\").default} */\n  geometry;\n  var hasZM = getHasZM(lineString);\n  return (\n    /** @type {EsriJSONPolyline} */\n    {\n      hasZ: hasZM.hasZ,\n      hasM: hasZM.hasM,\n      paths: [\n      /** @type {Array<EsriJSONPosition>} */\n      lineString.getCoordinates()]\n    }\n  );\n}\n/**\n * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n * @param {import(\"./Feature.js\").WriteOptions=} opt_options Write options.\n * @return {EsriJSONPolygon} EsriJSON geometry.\n */\n\n\nfunction writePolygonGeometry(geometry, opt_options) {\n  var polygon =\n  /** @type {import(\"../geom/Polygon.js\").default} */\n  geometry; // Esri geometries use the left-hand rule\n\n  var hasZM = getHasZM(polygon);\n  return (\n    /** @type {EsriJSONPolygon} */\n    {\n      hasZ: hasZM.hasZ,\n      hasM: hasZM.hasM,\n      rings:\n      /** @type {Array<Array<EsriJSONPosition>>} */\n      polygon.getCoordinates(false)\n    }\n  );\n}\n/**\n * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n * @param {import(\"./Feature.js\").WriteOptions=} opt_options Write options.\n * @return {EsriJSONPolyline} EsriJSON geometry.\n */\n\n\nfunction writeMultiLineStringGeometry(geometry, opt_options) {\n  var multiLineString =\n  /** @type {import(\"../geom/MultiLineString.js\").default} */\n  geometry;\n  var hasZM = getHasZM(multiLineString);\n  return (\n    /** @type {EsriJSONPolyline} */\n    {\n      hasZ: hasZM.hasZ,\n      hasM: hasZM.hasM,\n      paths:\n      /** @type {Array<Array<EsriJSONPosition>>} */\n      multiLineString.getCoordinates()\n    }\n  );\n}\n/**\n * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n * @param {import(\"./Feature.js\").WriteOptions=} opt_options Write options.\n * @return {EsriJSONMultipoint} EsriJSON geometry.\n */\n\n\nfunction writeMultiPointGeometry(geometry, opt_options) {\n  var multiPoint =\n  /** @type {import(\"../geom/MultiPoint.js\").default} */\n  geometry;\n  var hasZM = getHasZM(multiPoint);\n  return (\n    /** @type {EsriJSONMultipoint} */\n    {\n      hasZ: hasZM.hasZ,\n      hasM: hasZM.hasM,\n      points:\n      /** @type {Array<EsriJSONPosition>} */\n      multiPoint.getCoordinates()\n    }\n  );\n}\n/**\n * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n * @param {import(\"./Feature.js\").WriteOptions=} opt_options Write options.\n * @return {EsriJSONPolygon} EsriJSON geometry.\n */\n\n\nfunction writeMultiPolygonGeometry(geometry, opt_options) {\n  var hasZM = getHasZM(\n  /** @type {import(\"../geom/MultiPolygon.js\").default} */\n  geometry);\n  var coordinates =\n  /** @type {import(\"../geom/MultiPolygon.js\").default} */\n  geometry.getCoordinates(false);\n  var output = [];\n\n  for (var i = 0; i < coordinates.length; i++) {\n    for (var x = coordinates[i].length - 1; x >= 0; x--) {\n      output.push(coordinates[i][x]);\n    }\n  }\n\n  return (\n    /** @type {EsriJSONPolygon} */\n    {\n      hasZ: hasZM.hasZ,\n      hasM: hasZM.hasM,\n      rings: output\n    }\n  );\n}\n/**\n * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n * @param {import(\"./Feature.js\").WriteOptions=} opt_options Write options.\n * @return {EsriJSONGeometry} EsriJSON geometry.\n */\n\n\nfunction writeGeometry(geometry, opt_options) {\n  var geometryWriter = GEOMETRY_WRITERS[geometry.getType()];\n  return geometryWriter(\n  /** @type {import(\"../geom/Geometry.js\").default} */\n  transformWithOptions(geometry, true, opt_options), opt_options);\n}\n\nexport default EsriJSON;","map":null,"metadata":{},"sourceType":"module"}