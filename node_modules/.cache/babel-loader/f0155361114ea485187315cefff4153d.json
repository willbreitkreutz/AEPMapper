{"ast":null,"code":"var appTime = {\n  name: 'appTime',\n  reducer: function () {\n    return Date.now();\n  },\n  selectAppTime: function (state) {\n    return state.appTime;\n  }\n};\nvar changes = {\n  STARTED: 1,\n  FINISHED: -1,\n  FAILED: -1\n};\nvar re = /_(STARTED|FINISHED|FAILED)$/;\nvar asyncCount = {\n  name: 'asyncCount',\n  reducer: function (state, ref) {\n    if (state === void 0) state = 0;\n    var type = ref.type;\n    var result = re.exec(type);\n\n    if (!result) {\n      return state;\n    }\n\n    return state + changes[result[1]];\n  },\n  selectAsyncActive: function (state) {\n    return state.asyncCount > 0;\n  }\n};\n\nvar namedActionMiddleware = function (store) {\n  return function (next) {\n    return function (action) {\n      var actionCreator = action.actionCreator;\n      var args = action.args;\n\n      if (actionCreator) {\n        var found = store.meta.unboundActionCreators[actionCreator];\n\n        if (!found) {\n          throw Error(\"NoSuchActionCreator: \" + actionCreator);\n        }\n\n        return next(args ? found.apply(void 0, args) : found());\n      }\n\n      return next(action);\n    };\n  };\n};\n\nvar thunkMiddleware = function (extraArgCreators) {\n  return function (store) {\n    var extraArgs = extraArgCreators.reduce(function (result, fn) {\n      return Object.assign(result, fn(store));\n    }, {});\n    return function (next) {\n      return function (action) {\n        if (typeof action === 'function') {\n          var getState = store.getState;\n          var dispatch = store.dispatch;\n          return action(Object.assign({}, {\n            getState: getState,\n            dispatch: dispatch,\n            store: store\n          }, extraArgs));\n        }\n\n        return next(action);\n      };\n    };\n  };\n};\n\nfunction symbolObservablePonyfill(root) {\n  var result;\n  var Symbol = root.Symbol;\n\n  if (typeof Symbol === 'function') {\n    if (Symbol.observable) {\n      result = Symbol.observable;\n    } else {\n      result = Symbol('observable');\n      Symbol.observable = result;\n    }\n  } else {\n    result = '@@observable';\n  }\n\n  return result;\n}\n/* global window */\n\n\nvar root;\n\nif (typeof self !== 'undefined') {\n  root = self;\n} else if (typeof window !== 'undefined') {\n  root = window;\n} else if (typeof global !== 'undefined') {\n  root = global;\n} else if (typeof module !== 'undefined') {\n  root = module;\n} else {\n  root = Function('return this')();\n}\n\nvar result = symbolObservablePonyfill(root);\n/**\n * These are private action types reserved by Redux.\n * For any unknown actions, you must return the current state.\n * If the current state is undefined, you must return the initial state.\n * Do not reference these action types directly in your code.\n */\n\nvar ActionTypes = {\n  INIT: '@@redux/INIT' + Math.random().toString(36).substring(7).split('').join('.'),\n  REPLACE: '@@redux/REPLACE' + Math.random().toString(36).substring(7).split('').join('.')\n};\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n/**\n * @param {any} obj The object to inspect.\n * @returns {boolean} True if the argument appears to be a plain object.\n */\n\n\nfunction isPlainObject(obj) {\n  if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object' || obj === null) return false;\n  var proto = obj;\n\n  while (Object.getPrototypeOf(proto) !== null) {\n    proto = Object.getPrototypeOf(proto);\n  }\n\n  return Object.getPrototypeOf(obj) === proto;\n}\n/**\n * Creates a Redux store that holds the state tree.\n * The only way to change the data in the store is to call `dispatch()` on it.\n *\n * There should only be a single store in your app. To specify how different\n * parts of the state tree respond to actions, you may combine several reducers\n * into a single reducer function by using `combineReducers`.\n *\n * @param {Function} reducer A function that returns the next state tree, given\n * the current state tree and the action to handle.\n *\n * @param {any} [preloadedState] The initial state. You may optionally specify it\n * to hydrate the state from the server in universal apps, or to restore a\n * previously serialized user session.\n * If you use `combineReducers` to produce the root reducer function, this must be\n * an object with the same shape as `combineReducers` keys.\n *\n * @param {Function} [enhancer] The store enhancer. You may optionally specify it\n * to enhance the store with third-party capabilities such as middleware,\n * time travel, persistence, etc. The only store enhancer that ships with Redux\n * is `applyMiddleware()`.\n *\n * @returns {Store} A Redux store that lets you read the state, dispatch actions\n * and subscribe to changes.\n */\n\n\nfunction createStore(reducer, preloadedState, enhancer) {\n  var _ref2;\n\n  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {\n    enhancer = preloadedState;\n    preloadedState = undefined;\n  }\n\n  if (typeof enhancer !== 'undefined') {\n    if (typeof enhancer !== 'function') {\n      throw new Error('Expected the enhancer to be a function.');\n    }\n\n    return enhancer(createStore)(reducer, preloadedState);\n  }\n\n  if (typeof reducer !== 'function') {\n    throw new Error('Expected the reducer to be a function.');\n  }\n\n  var currentReducer = reducer;\n  var currentState = preloadedState;\n  var currentListeners = [];\n  var nextListeners = currentListeners;\n  var isDispatching = false;\n\n  function ensureCanMutateNextListeners() {\n    if (nextListeners === currentListeners) {\n      nextListeners = currentListeners.slice();\n    }\n  }\n  /**\n   * Reads the state tree managed by the store.\n   *\n   * @returns {any} The current state tree of your application.\n   */\n\n\n  function getState() {\n    if (isDispatching) {\n      throw new Error('You may not call store.getState() while the reducer is executing. ' + 'The reducer has already received the state as an argument. ' + 'Pass it down from the top reducer instead of reading it from the store.');\n    }\n\n    return currentState;\n  }\n  /**\n   * Adds a change listener. It will be called any time an action is dispatched,\n   * and some part of the state tree may potentially have changed. You may then\n   * call `getState()` to read the current state tree inside the callback.\n   *\n   * You may call `dispatch()` from a change listener, with the following\n   * caveats:\n   *\n   * 1. The subscriptions are snapshotted just before every `dispatch()` call.\n   * If you subscribe or unsubscribe while the listeners are being invoked, this\n   * will not have any effect on the `dispatch()` that is currently in progress.\n   * However, the next `dispatch()` call, whether nested or not, will use a more\n   * recent snapshot of the subscription list.\n   *\n   * 2. The listener should not expect to see all state changes, as the state\n   * might have been updated multiple times during a nested `dispatch()` before\n   * the listener is called. It is, however, guaranteed that all subscribers\n   * registered before the `dispatch()` started will be called with the latest\n   * state by the time it exits.\n   *\n   * @param {Function} listener A callback to be invoked on every dispatch.\n   * @returns {Function} A function to remove this change listener.\n   */\n\n\n  function subscribe(listener) {\n    if (typeof listener !== 'function') {\n      throw new Error('Expected the listener to be a function.');\n    }\n\n    if (isDispatching) {\n      throw new Error('You may not call store.subscribe() while the reducer is executing. ' + 'If you would like to be notified after the store has been updated, subscribe from a ' + 'component and invoke store.getState() in the callback to access the latest state. ' + 'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.');\n    }\n\n    var isSubscribed = true;\n    ensureCanMutateNextListeners();\n    nextListeners.push(listener);\n    return function unsubscribe() {\n      if (!isSubscribed) {\n        return;\n      }\n\n      if (isDispatching) {\n        throw new Error('You may not unsubscribe from a store listener while the reducer is executing. ' + 'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.');\n      }\n\n      isSubscribed = false;\n      ensureCanMutateNextListeners();\n      var index = nextListeners.indexOf(listener);\n      nextListeners.splice(index, 1);\n    };\n  }\n  /**\n   * Dispatches an action. It is the only way to trigger a state change.\n   *\n   * The `reducer` function, used to create the store, will be called with the\n   * current state tree and the given `action`. Its return value will\n   * be considered the **next** state of the tree, and the change listeners\n   * will be notified.\n   *\n   * The base implementation only supports plain object actions. If you want to\n   * dispatch a Promise, an Observable, a thunk, or something else, you need to\n   * wrap your store creating function into the corresponding middleware. For\n   * example, see the documentation for the `redux-thunk` package. Even the\n   * middleware will eventually dispatch plain object actions using this method.\n   *\n   * @param {Object} action A plain object representing “what changed”. It is\n   * a good idea to keep actions serializable so you can record and replay user\n   * sessions, or use the time travelling `redux-devtools`. An action must have\n   * a `type` property which may not be `undefined`. It is a good idea to use\n   * string constants for action types.\n   *\n   * @returns {Object} For convenience, the same action object you dispatched.\n   *\n   * Note that, if you use a custom middleware, it may wrap `dispatch()` to\n   * return something else (for example, a Promise you can await).\n   */\n\n\n  function dispatch(action) {\n    if (!isPlainObject(action)) {\n      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');\n    }\n\n    if (typeof action.type === 'undefined') {\n      throw new Error('Actions may not have an undefined \"type\" property. ' + 'Have you misspelled a constant?');\n    }\n\n    if (isDispatching) {\n      throw new Error('Reducers may not dispatch actions.');\n    }\n\n    try {\n      isDispatching = true;\n      currentState = currentReducer(currentState, action);\n    } finally {\n      isDispatching = false;\n    }\n\n    var listeners = currentListeners = nextListeners;\n\n    for (var i = 0; i < listeners.length; i++) {\n      var listener = listeners[i];\n      listener();\n    }\n\n    return action;\n  }\n  /**\n   * Replaces the reducer currently used by the store to calculate the state.\n   *\n   * You might need this if your app implements code splitting and you want to\n   * load some of the reducers dynamically. You might also need this if you\n   * implement a hot reloading mechanism for Redux.\n   *\n   * @param {Function} nextReducer The reducer for the store to use instead.\n   * @returns {void}\n   */\n\n\n  function replaceReducer(nextReducer) {\n    if (typeof nextReducer !== 'function') {\n      throw new Error('Expected the nextReducer to be a function.');\n    }\n\n    currentReducer = nextReducer;\n    dispatch({\n      type: ActionTypes.REPLACE\n    });\n  }\n  /**\n   * Interoperability point for observable/reactive libraries.\n   * @returns {observable} A minimal observable of state changes.\n   * For more information, see the observable proposal:\n   * https://github.com/tc39/proposal-observable\n   */\n\n\n  function observable() {\n    var _ref;\n\n    var outerSubscribe = subscribe;\n    return _ref = {\n      /**\n       * The minimal observable subscription method.\n       * @param {Object} observer Any object that can be used as an observer.\n       * The observer object should have a `next` method.\n       * @returns {subscription} An object with an `unsubscribe` method that can\n       * be used to unsubscribe the observable from the store, and prevent further\n       * emission of values from the observable.\n       */\n      subscribe: function subscribe(observer) {\n        if ((typeof observer === 'undefined' ? 'undefined' : _typeof(observer)) !== 'object' || observer === null) {\n          throw new TypeError('Expected the observer to be an object.');\n        }\n\n        function observeState() {\n          if (observer.next) {\n            observer.next(getState());\n          }\n        }\n\n        observeState();\n        var unsubscribe = outerSubscribe(observeState);\n        return {\n          unsubscribe: unsubscribe\n        };\n      }\n    }, _ref[result] = function () {\n      return this;\n    }, _ref;\n  } // When a store is created, an \"INIT\" action is dispatched so that every\n  // reducer returns their initial state. This effectively populates\n  // the initial state tree.\n\n\n  dispatch({\n    type: ActionTypes.INIT\n  });\n  return _ref2 = {\n    dispatch: dispatch,\n    subscribe: subscribe,\n    getState: getState,\n    replaceReducer: replaceReducer\n  }, _ref2[result] = observable, _ref2;\n}\n/**\n * Prints a warning in the console if it exists.\n *\n * @param {String} message The warning message.\n * @returns {void}\n */\n\n\nfunction warning(message) {\n  /* eslint-disable no-console */\n  if (typeof console !== 'undefined' && typeof console.error === 'function') {\n    console.error(message);\n  }\n  /* eslint-enable no-console */\n\n\n  try {\n    // This error was thrown as a convenience so that if you enable\n    // \"break on all exceptions\" in your console,\n    // it would pause the execution at this line.\n    throw new Error(message);\n  } catch (e) {} // eslint-disable-line no-empty\n\n}\n\nfunction getUndefinedStateErrorMessage(key, action) {\n  var actionType = action && action.type;\n  var actionDescription = actionType && 'action \"' + String(actionType) + '\"' || 'an action';\n  return 'Given ' + actionDescription + ', reducer \"' + key + '\" returned undefined. ' + 'To ignore an action, you must explicitly return the previous state. ' + 'If you want this reducer to hold no value, you can return null instead of undefined.';\n}\n\nfunction getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {\n  var reducerKeys = Object.keys(reducers);\n  var argumentName = action && action.type === ActionTypes.INIT ? 'preloadedState argument passed to createStore' : 'previous state received by the reducer';\n\n  if (reducerKeys.length === 0) {\n    return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';\n  }\n\n  if (!isPlainObject(inputState)) {\n    return 'The ' + argumentName + ' has unexpected type of \"' + {}.toString.call(inputState).match(/\\s([a-z|A-Z]+)/)[1] + '\". Expected argument to be an object with the following ' + ('keys: \"' + reducerKeys.join('\", \"') + '\"');\n  }\n\n  var unexpectedKeys = Object.keys(inputState).filter(function (key) {\n    return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key];\n  });\n  unexpectedKeys.forEach(function (key) {\n    unexpectedKeyCache[key] = true;\n  });\n  if (action && action.type === ActionTypes.REPLACE) return;\n\n  if (unexpectedKeys.length > 0) {\n    return 'Unexpected ' + (unexpectedKeys.length > 1 ? 'keys' : 'key') + ' ' + ('\"' + unexpectedKeys.join('\", \"') + '\" found in ' + argumentName + '. ') + 'Expected to find one of the known reducer keys instead: ' + ('\"' + reducerKeys.join('\", \"') + '\". Unexpected keys will be ignored.');\n  }\n}\n\nfunction assertReducerShape(reducers) {\n  Object.keys(reducers).forEach(function (key) {\n    var reducer = reducers[key];\n    var initialState = reducer(undefined, {\n      type: ActionTypes.INIT\n    });\n\n    if (typeof initialState === 'undefined') {\n      throw new Error('Reducer \"' + key + '\" returned undefined during initialization. ' + 'If the state passed to the reducer is undefined, you must ' + 'explicitly return the initial state. The initial state may ' + 'not be undefined. If you don\\'t want to set a value for this reducer, ' + 'you can use null instead of undefined.');\n    }\n\n    var type = '@@redux/PROBE_UNKNOWN_ACTION_' + Math.random().toString(36).substring(7).split('').join('.');\n\n    if (typeof reducer(undefined, {\n      type: type\n    }) === 'undefined') {\n      throw new Error('Reducer \"' + key + '\" returned undefined when probed with a random type. ' + ('Don\\'t try to handle ' + ActionTypes.INIT + ' or other actions in \"redux/*\" ') + 'namespace. They are considered private. Instead, you must return the ' + 'current state for any unknown actions, unless it is undefined, ' + 'in which case you must return the initial state, regardless of the ' + 'action type. The initial state may not be undefined, but can be null.');\n    }\n  });\n}\n/**\n * Turns an object whose values are different reducer functions, into a single\n * reducer function. It will call every child reducer, and gather their results\n * into a single state object, whose keys correspond to the keys of the passed\n * reducer functions.\n *\n * @param {Object} reducers An object whose values correspond to different\n * reducer functions that need to be combined into one. One handy way to obtain\n * it is to use ES6 `import * as reducers` syntax. The reducers may never return\n * undefined for any action. Instead, they should return their initial state\n * if the state passed to them was undefined, and the current state for any\n * unrecognized action.\n *\n * @returns {Function} A reducer function that invokes every reducer inside the\n * passed object, and builds a state object with the same shape.\n */\n\n\nfunction combineReducers(reducers) {\n  var reducerKeys = Object.keys(reducers);\n  var finalReducers = {};\n\n  for (var i = 0; i < reducerKeys.length; i++) {\n    var key = reducerKeys[i];\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof reducers[key] === 'undefined') {\n        warning('No reducer provided for key \"' + key + '\"');\n      }\n    }\n\n    if (typeof reducers[key] === 'function') {\n      finalReducers[key] = reducers[key];\n    }\n  }\n\n  var finalReducerKeys = Object.keys(finalReducers);\n  var unexpectedKeyCache = void 0;\n\n  if (process.env.NODE_ENV !== 'production') {\n    unexpectedKeyCache = {};\n  }\n\n  var shapeAssertionError = void 0;\n\n  try {\n    assertReducerShape(finalReducers);\n  } catch (e) {\n    shapeAssertionError = e;\n  }\n\n  return function combination() {\n    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var action = arguments[1];\n\n    if (shapeAssertionError) {\n      throw shapeAssertionError;\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache);\n\n      if (warningMessage) {\n        warning(warningMessage);\n      }\n    }\n\n    var hasChanged = false;\n    var nextState = {};\n\n    for (var _i = 0; _i < finalReducerKeys.length; _i++) {\n      var _key = finalReducerKeys[_i];\n      var reducer = finalReducers[_key];\n      var previousStateForKey = state[_key];\n      var nextStateForKey = reducer(previousStateForKey, action);\n\n      if (typeof nextStateForKey === 'undefined') {\n        var errorMessage = getUndefinedStateErrorMessage(_key, action);\n        throw new Error(errorMessage);\n      }\n\n      nextState[_key] = nextStateForKey;\n      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;\n    }\n\n    return hasChanged ? nextState : state;\n  };\n}\n\nfunction bindActionCreator(actionCreator, dispatch) {\n  return function () {\n    return dispatch(actionCreator.apply(this, arguments));\n  };\n}\n/**\n * Turns an object whose values are action creators, into an object with the\n * same keys, but with every function wrapped into a `dispatch` call so they\n * may be invoked directly. This is just a convenience method, as you can call\n * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.\n *\n * For convenience, you can also pass a single function as the first argument,\n * and get a function in return.\n *\n * @param {Function|Object} actionCreators An object whose values are action\n * creator functions. One handy way to obtain it is to use ES6 `import * as`\n * syntax. You may also pass a single function.\n *\n * @param {Function} dispatch The `dispatch` function available on your Redux\n * store.\n *\n * @returns {Function|Object} The object mimicking the original object, but with\n * every action creator wrapped into the `dispatch` call. If you passed a\n * function as `actionCreators`, the return value will also be a single\n * function.\n */\n\n\nfunction bindActionCreators(actionCreators, dispatch) {\n  if (typeof actionCreators === 'function') {\n    return bindActionCreator(actionCreators, dispatch);\n  }\n\n  if ((typeof actionCreators === 'undefined' ? 'undefined' : _typeof(actionCreators)) !== 'object' || actionCreators === null) {\n    throw new Error('bindActionCreators expected an object or a function, instead received ' + (actionCreators === null ? 'null' : typeof actionCreators === 'undefined' ? 'undefined' : _typeof(actionCreators)) + '. ' + 'Did you write \"import ActionCreators from\" instead of \"import * as ActionCreators from\"?');\n  }\n\n  var keys = Object.keys(actionCreators);\n  var boundActionCreators = {};\n\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    var actionCreator = actionCreators[key];\n\n    if (typeof actionCreator === 'function') {\n      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);\n    }\n  }\n\n  return boundActionCreators;\n}\n/**\n * Composes single-argument functions from right to left. The rightmost\n * function can take multiple arguments as it provides the signature for\n * the resulting composite function.\n *\n * @param {...Function} funcs The functions to compose.\n * @returns {Function} A function obtained by composing the argument functions\n * from right to left. For example, compose(f, g, h) is identical to doing\n * (...args) => f(g(h(...args))).\n */\n\n\nfunction compose() {\n  for (var _len = arguments.length, funcs = Array(_len), _key = 0; _key < _len; _key++) {\n    funcs[_key] = arguments[_key];\n  }\n\n  if (funcs.length === 0) {\n    return function (arg) {\n      return arg;\n    };\n  }\n\n  if (funcs.length === 1) {\n    return funcs[0];\n  }\n\n  return funcs.reduce(function (a, b) {\n    return function () {\n      return a(b.apply(undefined, arguments));\n    };\n  });\n}\n/**\n * Creates a store enhancer that applies middleware to the dispatch method\n * of the Redux store. This is handy for a variety of tasks, such as expressing\n * asynchronous actions in a concise manner, or logging every action payload.\n *\n * See `redux-thunk` package as an example of the Redux middleware.\n *\n * Because middleware is potentially asynchronous, this should be the first\n * store enhancer in the composition chain.\n *\n * Note that each middleware will be given the `dispatch` and `getState` functions\n * as named arguments.\n *\n * @param {...Function} middlewares The middleware chain to be applied.\n * @returns {Function} A store enhancer applying the middleware.\n */\n\n\nfunction applyMiddleware() {\n  for (var _len = arguments.length, middlewares = Array(_len), _key = 0; _key < _len; _key++) {\n    middlewares[_key] = arguments[_key];\n  }\n\n  return function (createStore) {\n    return function () {\n      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      var store = createStore.apply(undefined, args);\n\n      var _dispatch = function dispatch() {\n        throw new Error('Dispatching while constructing your middleware is not allowed. ' + 'Other middleware would not be applied to this dispatch.');\n      };\n\n      var middlewareAPI = {\n        getState: store.getState,\n        dispatch: function dispatch() {\n          return _dispatch.apply(undefined, arguments);\n        }\n      };\n      var chain = middlewares.map(function (middleware) {\n        return middleware(middlewareAPI);\n      });\n      _dispatch = compose.apply(undefined, chain)(store.dispatch);\n      return _extends({}, store, {\n        dispatch: _dispatch\n      });\n    };\n  };\n}\n/*\n * This is a dummy function to check if the function name has been altered by minification.\n * If the function has been minified and NODE_ENV !== 'production', warn the user.\n */\n\n\nfunction isCrushed() {}\n\nif (process.env.NODE_ENV !== 'production' && typeof isCrushed.name === 'string' && isCrushed.name !== 'isCrushed') {\n  warning(\"You are currently using minified code outside of NODE_ENV === 'production'. \" + 'This means that you are running a slower development build of Redux. ' + 'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' + 'or DefinePlugin for webpack (http://stackoverflow.com/questions/30030031) ' + 'to ensure you have the correct code for your production build.');\n} // Modified to expose all of `store` to middleware instead of just\n\n\nvar customApplyMiddleware = function () {\n  var middlewares = [],\n      len = arguments.length;\n\n  while (len--) middlewares[len] = arguments[len];\n\n  return function (createStore$$1) {\n    return function (reducer, preloadedState, enhancer) {\n      var store = createStore$$1(reducer, preloadedState, enhancer);\n      var chain = middlewares.map(function (middleware) {\n        return middleware(store);\n      });\n      store.dispatch = compose.apply(void 0, chain)(store.dispatch);\n      return store;\n    };\n  };\n};\n\nfunction defaultEqualityCheck(a, b) {\n  return a === b;\n}\n\nfunction areArgumentsShallowlyEqual(equalityCheck, prev, next) {\n  if (prev === null || next === null || prev.length !== next.length) {\n    return false;\n  } // Do this in a for loop (and not a `forEach` or an `every`) so we can determine equality as fast as possible.\n\n\n  var length = prev.length;\n\n  for (var i = 0; i < length; i++) {\n    if (!equalityCheck(prev[i], next[i])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction defaultMemoize(func) {\n  var equalityCheck = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultEqualityCheck;\n  var lastArgs = null;\n  var lastResult = null; // we reference arguments instead of spreading them for performance reasons\n\n  return function () {\n    if (!areArgumentsShallowlyEqual(equalityCheck, lastArgs, arguments)) {\n      // apply arguments instead of spreading for performance.\n      lastResult = func.apply(null, arguments);\n    }\n\n    lastArgs = arguments;\n    return lastResult;\n  };\n}\n\nfunction getDependencies(funcs) {\n  var dependencies = Array.isArray(funcs[0]) ? funcs[0] : funcs;\n\n  if (!dependencies.every(function (dep) {\n    return typeof dep === 'function';\n  })) {\n    var dependencyTypes = dependencies.map(function (dep) {\n      return typeof dep;\n    }).join(', ');\n    throw new Error('Selector creators expect all input-selectors to be functions, ' + ('instead received the following types: [' + dependencyTypes + ']'));\n  }\n\n  return dependencies;\n}\n\nfunction createSelectorCreator(memoize) {\n  for (var _len = arguments.length, memoizeOptions = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    memoizeOptions[_key - 1] = arguments[_key];\n  }\n\n  return function () {\n    for (var _len2 = arguments.length, funcs = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      funcs[_key2] = arguments[_key2];\n    }\n\n    var recomputations = 0;\n    var resultFunc = funcs.pop();\n    var dependencies = getDependencies(funcs);\n    var memoizedResultFunc = memoize.apply(undefined, [function () {\n      recomputations++; // apply arguments instead of spreading for performance.\n\n      return resultFunc.apply(null, arguments);\n    }].concat(memoizeOptions)); // If a selector is called with the exact same arguments we don't need to traverse our dependencies again.\n\n    var selector = defaultMemoize(function () {\n      var params = [];\n      var length = dependencies.length;\n\n      for (var i = 0; i < length; i++) {\n        // apply arguments instead of spreading and mutate a local list of params for performance.\n        params.push(dependencies[i].apply(null, arguments));\n      } // apply arguments instead of spreading for performance.\n\n\n      return memoizedResultFunc.apply(null, params);\n    });\n    selector.resultFunc = resultFunc;\n\n    selector.recomputations = function () {\n      return recomputations;\n    };\n\n    selector.resetRecomputations = function () {\n      return recomputations = 0;\n    };\n\n    return selector;\n  };\n}\n\nvar createSelector = createSelectorCreator(defaultMemoize);\n\nvar ensureFn = function (obj, name) {\n  if (typeof name !== 'string') {\n    return name;\n  }\n\n  var found = obj[name];\n\n  if (!found) {\n    throw Error('No selector ' + name + ' found on the obj.');\n  }\n\n  return found;\n};\n\nvar createSelector$1 = function () {\n  var fns = [],\n      len = arguments.length;\n\n  while (len--) fns[len] = arguments[len];\n\n  var resultFunc = fns.slice(-1)[0];\n\n  var deferredSelector = function (obj, deps) {\n    var newArgs = deps.map(function (fn) {\n      return ensureFn(obj, fn);\n    });\n    newArgs.push(resultFunc);\n    return createSelector.apply(void 0, newArgs);\n  };\n\n  deferredSelector.deps = fns.slice(0, -1);\n  deferredSelector.resultFunc = resultFunc;\n  return deferredSelector;\n};\n\nvar resolveSelectors = function (obj) {\n  // an item is resolved if it is either a\n  // function with no dependencies or if\n  // it's on the object with no dependencies\n  var isResolved = function (name) {\n    return name.call && !name.deps || !obj[name].deps;\n  }; // flag for checking if we have *any*\n\n\n  var hasAtLeastOneResolved = false; // extract all deps and any resolved items\n\n  var loop = function (selectorName) {\n    var fn = obj[selectorName];\n\n    if (!isResolved(selectorName)) {\n      fn.deps = fn.deps.map(function (val, index) {\n        // if it is a function not a string\n        if (val.call) {\n          // look for it already on the object\n          for (var key in obj) {\n            if (obj[key] === val) {\n              // return its name if found\n              return key;\n            }\n          } // we didn't find it and it doesn't have a name\n          // but if it's a fully resolved selector that's ok\n\n\n          if (!val.deps) {\n            hasAtLeastOneResolved = true;\n            return val;\n          }\n        } // the `val` is a string that exists on the object return the string\n        // we'll resolve it later\n\n\n        if (obj[val]) {\n          return val;\n        } // if we get here, its a string that doesn't exist on the object\n        // which won't work, so we throw a helpful error\n\n\n        throw Error(\"The input selector at index \" + index + \" for '\" + selectorName + \"' is missing from the object passed to resolveSelectors()\");\n      });\n    } else {\n      hasAtLeastOneResolved = true;\n    }\n  };\n\n  for (var selectorName in obj) loop(selectorName);\n\n  if (!hasAtLeastOneResolved) {\n    throw Error(\"You must pass at least one real selector. If they're all string references there's no\");\n  }\n\n  var depsAreResolved = function (deps) {\n    return deps.every(isResolved);\n  };\n\n  var resolve = function () {\n    var hasUnresolved = false;\n\n    for (var selectorName in obj) {\n      var fn = obj[selectorName];\n\n      if (!isResolved(selectorName)) {\n        hasUnresolved = true;\n\n        if (depsAreResolved(fn.deps)) {\n          // we could just use `obj[selectorName] = fn(obj, fn.deps)`, but that\n          // has a significant performance impact when trying to perform this\n          // on a large object (> 1000). More on this here:\n          // http://2ality.com/2014/01/object-assign.html\n          var selectorFn = fn(obj, fn.deps);\n          delete obj[selectorName];\n          obj[selectorName] = selectorFn;\n        }\n      }\n    }\n\n    return hasUnresolved;\n  };\n\n  var startTime;\n\n  while (resolve()) {\n    if (!startTime) {\n      startTime = Date.now();\n    }\n\n    var duration = Date.now() - startTime;\n\n    if (duration > 500) {\n      throw Error('Could not resolve selector dependencies.');\n    }\n  }\n\n  return obj;\n};\n\nvar debug = false;\n\ntry {\n  debug = !!window.localStorage.debug;\n} catch (e) {}\n\nvar HAS_DEBUG_FLAG = debug || false;\nvar HAS_WINDOW = typeof window !== 'undefined';\nvar IS_BROWSER = HAS_WINDOW || typeof self !== 'undefined';\nvar IS_PROD = process.env.NODE_ENV === 'production';\n\nvar fallback = function (func) {\n  setTimeout(func, 0);\n};\n\nvar raf = IS_BROWSER && self.requestAnimationFrame ? self.requestAnimationFrame : fallback;\nvar ric = IS_BROWSER && self.requestIdleCallback ? self.requestIdleCallback : fallback; // can dump this once IE 11 support is no longer necessary\n\nvar isPassiveSupported = function () {\n  var passiveSupported = false;\n\n  try {\n    var options = Object.defineProperty({}, 'passive', {\n      get: function () {\n        passiveSupported = true;\n      }\n    });\n    window.addEventListener('test', options, options);\n    window.removeEventListener('test', options, options);\n  } catch (err) {\n    passiveSupported = false;\n  }\n\n  return passiveSupported;\n};\n\nvar PASSIVE_EVENTS_SUPPORTED = isPassiveSupported();\n\nvar startsWith = function (string, searchString) {\n  return string.substr(0, searchString.length) === searchString;\n};\n\nvar flattenExtractedToObject = function (extracted) {\n  var result = {};\n\n  for (var appName in extracted) {\n    Object.assign(result, extracted[appName]);\n  }\n\n  return result;\n};\n\nvar flattenExtractedToArray = function (extracted) {\n  var accum = [];\n\n  for (var appName in extracted) {\n    accum.push.apply(accum, extracted[appName]);\n  }\n\n  return accum;\n};\n\nvar addGlobalListener = function (eventName, handler, opts) {\n  if (opts === void 0) opts = {\n    passive: false\n  };\n\n  if (IS_BROWSER) {\n    if (opts.passive) {\n      if (PASSIVE_EVENTS_SUPPORTED) {\n        self.addEventListener(eventName, handler, {\n          passive: true\n        });\n      } else {\n        self.addEventListener(eventName, debounce(handler, 200), false);\n      }\n    } else {\n      self.addEventListener(eventName, handler);\n    }\n  }\n};\n\nvar selectorNameToValueName = function (name) {\n  var start = name[0] === 's' ? 6 : 5;\n  return name[start].toLowerCase() + name.slice(start + 1);\n};\n\nvar debounce = function (fn, wait) {\n  var timeout;\n\n  var debounced = function () {\n    var ctx = this;\n    var args = arguments;\n    clearTimeout(timeout);\n    timeout = setTimeout(function () {\n      fn.apply(ctx, args);\n    }, wait);\n  };\n\n  debounced.cancel = function () {\n    clearTimeout(timeout);\n  };\n\n  return debounced;\n};\n\nvar saveScrollPosition = function () {\n  history.replaceState({\n    height: window.innerHeight,\n    width: window.innerWidth,\n    y: window.scrollY,\n    x: window.scrollX\n  }, '');\n};\n\nvar restoreScrollPosition = function () {\n  var state = history.state;\n\n  if (state) {\n    // we'll force it to our known height since the DOM rendering may\n    // be async and the height may not be restored yet.\n    setTimeout(function () {\n      var newStyle = \"height: \" + state.height + \"px; width: \" + state.width + \"px;\";\n      document.body.setAttribute('style', newStyle);\n      window.scrollTo(state.x, state.y);\n      ric(function () {\n        return document.body.removeAttribute('style');\n      });\n    });\n  }\n};\n\nvar initScrollPosition = function () {\n  if (!HAS_WINDOW) {\n    return;\n  } // turn off browser scroll restoration if available\n\n\n  if (history.scrollRestoration) {\n    history.scrollRestoration = 'manual';\n  }\n\n  addGlobalListener('popstate', restoreScrollPosition);\n  addGlobalListener('scroll', debounce(saveScrollPosition, 300), {\n    passive: true\n  });\n  restoreScrollPosition();\n};\n\nvar normalizeBundle = function (bundle) {\n  var name = bundle.name;\n\n  if (!name) {\n    throw TypeError('bundles must have a \"name\" property');\n  }\n\n  var result = {\n    name: name,\n    reducer: bundle.reducer || bundle.getReducer && bundle.getReducer() || null,\n    init: bundle.init || null,\n    extraArgCreators: bundle.getExtraArgs || null,\n    middlewareCreators: bundle.getMiddleware,\n    actionCreators: null,\n    selectors: null,\n    reactorNames: null,\n    rawBundle: bundle\n  };\n  Object.keys(bundle).forEach(function (key) {\n    if (startsWith(key, 'do')) {\n      (result.actionCreators || (result.actionCreators = {}))[key] = bundle[key];\n      return;\n    }\n\n    var isSelector = startsWith(key, 'select');\n    var isReactor = startsWith(key, 'react');\n\n    if (isSelector || isReactor) {\n      (result.selectors || (result.selectors = {}))[key] = bundle[key];\n\n      if (isReactor) {\n        (result.reactorNames || (result.reactorNames = [])).push(key);\n      }\n    }\n  });\n  return result;\n};\n\nvar createChunk = function (rawBundles) {\n  var normalizedBundles = rawBundles.map(normalizeBundle);\n  var result = {\n    bundleNames: [],\n    reducers: {},\n    selectors: {},\n    actionCreators: {},\n    rawBundles: [],\n    processedBundles: [],\n    initMethods: [],\n    middlewareCreators: [],\n    extraArgCreators: [],\n    reactorNames: []\n  };\n  normalizedBundles.forEach(function (bundle) {\n    var obj, ref;\n    result.bundleNames.push(bundle.name);\n    Object.assign(result.selectors, bundle.selectors);\n    Object.assign(result.actionCreators, bundle.actionCreators);\n\n    if (bundle.reducer) {\n      Object.assign(result.reducers, (obj = {}, obj[bundle.name] = bundle.reducer, obj));\n    }\n\n    if (bundle.init) {\n      result.initMethods.push(bundle.init);\n    }\n\n    if (bundle.middlewareCreators) {\n      result.middlewareCreators.push(bundle.middlewareCreators);\n    }\n\n    if (bundle.extraArgCreators) {\n      result.extraArgCreators.push(bundle.extraArgCreators);\n    }\n\n    if (bundle.reactorNames) {\n      (ref = result.reactorNames).push.apply(ref, bundle.reactorNames);\n    }\n\n    result.processedBundles.push(bundle);\n    result.rawBundles.push(bundle.rawBundle);\n  });\n  return result;\n};\n\nvar addBindingMethods = function (store) {\n  store.subscriptions = {\n    watchedValues: {}\n  };\n  var subscriptions = store.subscriptions.set = new Set();\n  var watchedSelectors = store.subscriptions.watchedSelectors = {};\n\n  var watch = function (selectorName) {\n    watchedSelectors[selectorName] = (watchedSelectors[selectorName] || 0) + 1;\n  };\n\n  var unwatch = function (selectorName) {\n    var count = watchedSelectors[selectorName] - 1;\n\n    if (count === 0) {\n      delete watchedSelectors[selectorName];\n    } else {\n      watchedSelectors[selectorName] = count;\n    }\n  }; // add single store subscription for tracking watched changes\n\n\n  store.subscribe(function () {\n    var newValues = watchedSelectors.all ? store.selectAll() : store.select(Object.keys(watchedSelectors));\n    var ref = store.subscriptions;\n    var watchedValues = ref.watchedValues; // the only diffing in the app happens here\n\n    var changed = {};\n\n    for (var key in newValues) {\n      var val = newValues[key];\n\n      if (val !== watchedValues[key]) {\n        changed[key] = val;\n      }\n    }\n\n    store.subscriptions.watchedValues = newValues; // look through subscriptions to trigger\n\n    subscriptions.forEach(function (subscription) {\n      var relevantChanges = {};\n      var hasChanged = false;\n\n      if (subscription.names === 'all') {\n        Object.assign(relevantChanges, changed);\n        hasChanged = !!Object.keys(relevantChanges).length;\n      } else {\n        subscription.names.forEach(function (name) {\n          if (changed.hasOwnProperty(name)) {\n            relevantChanges[name] = changed[name];\n            hasChanged = true;\n          }\n        });\n      }\n\n      if (hasChanged) {\n        subscription.fn(relevantChanges);\n      }\n    });\n  }); // this exists separately in order to support\n  // subscribing to all changes even after lazy-loading\n  // additional bundles\n\n  store.subscribeToAllChanges = function (callback) {\n    return store.subscribeToSelectors('all', callback);\n  }; // given an array of selector names, it will call the\n  // callback any time those have changed with an object\n  // containing only changed values\n\n\n  store.subscribeToSelectors = function (keys, callback) {\n    var isAll = keys === 'all'; // re-use loop for double duty\n    // extract names, but also ensure\n    // selector actually exists on store\n\n    var subscription = {\n      fn: callback,\n      names: isAll ? 'all' : keys.map(selectorNameToValueName)\n    };\n    subscriptions.add(subscription);\n    isAll ? watch('all') : keys.forEach(watch); // make sure starting values are in watched so we can\n    // track changes\n\n    Object.assign(store.subscriptions.watchedValues, isAll ? store.selectAll() : store.select(keys)); // return function that can be used to unsubscribe\n\n    return function () {\n      subscriptions.delete(subscription);\n      isAll ? unwatch('all') : keys.forEach(unwatch);\n    };\n  };\n};\n\nvar bindSelectorsToStore = function (store, selectors) {\n  var loop = function (key) {\n    var selector = selectors[key];\n\n    if (!store[key]) {\n      store[key] = function () {\n        return selector(store.getState());\n      };\n    }\n  };\n\n  for (var key in selectors) loop(key);\n};\n\nvar decorateStore = function (store, processed) {\n  if (!store.meta) {\n    store.meta = {\n      chunks: [],\n      unboundSelectors: {},\n      unboundActionCreators: {},\n      reactorNames: []\n    };\n  }\n\n  var meta = store.meta; // attach for reference\n\n  meta.chunks.push(processed); // grab existing unbound (but resolved) selectors, combine with new ones\n\n  var combinedSelectors = Object.assign(meta.unboundSelectors, processed.selectors); // run resolver\n\n  resolveSelectors(combinedSelectors); // update collection of resolved selectors\n\n  meta.unboundSelectors = combinedSelectors; // make sure all selectors are bound (won't overwrite if already bound)\n\n  bindSelectorsToStore(store, combinedSelectors); // build our list of reactor names\n\n  meta.reactorNames = meta.reactorNames.concat(processed.reactorNames); // extend global collections with new stuff\n\n  Object.assign(meta.unboundActionCreators, processed.actionCreators); // bind and attach only the next action creators to the store\n\n  Object.assign(store, bindActionCreators(processed.actionCreators, store.dispatch)); // run any new init methods\n\n  processed.initMethods.forEach(function (fn) {\n    return fn(store);\n  });\n};\n\nvar enableBatchDispatch = function (reducer) {\n  return function (state, action) {\n    if (action.type === 'BATCH_ACTIONS') {\n      return action.actions.reduce(reducer, state);\n    }\n\n    return reducer(state, action);\n  };\n};\n\nvar enableReplaceState = function (reducer) {\n  return function (state, action) {\n    if (action.type === 'REPLACE_STATE') {\n      return reducer(action.payload, action);\n    }\n\n    return reducer(state, action);\n  };\n};\n\nvar enhanceReducer = compose(enableBatchDispatch, enableReplaceState);\n\nvar devTools = function () {\n  return HAS_WINDOW && window.__REDUX_DEVTOOLS_EXTENSION__ && (HAS_DEBUG_FLAG || !IS_PROD) ? window.__REDUX_DEVTOOLS_EXTENSION__() : function (a) {\n    return a;\n  };\n};\n\nvar composeBundles = function () {\n  var bundles = [],\n      len = arguments.length;\n\n  while (len--) bundles[len] = arguments[len]; // build out object of extracted bundle info\n\n\n  var firstChunk = createChunk(bundles);\n  return function (data) {\n    // actually init our store\n    var store = createStore(enhanceReducer(combineReducers(firstChunk.reducers)), data, compose(customApplyMiddleware.apply(void 0, [namedActionMiddleware, thunkMiddleware(firstChunk.extraArgCreators)].concat(firstChunk.middlewareCreators.map(function (fn) {\n      return fn(firstChunk);\n    }))), devTools())); // get values from an array of selector names\n\n    store.select = function (selectorNames) {\n      return selectorNames.reduce(function (obj, name) {\n        if (!store[name]) {\n          throw Error(\"SelectorNotFound \" + name);\n        }\n\n        obj[selectorNameToValueName(name)] = store[name]();\n        return obj;\n      }, {});\n    }; // get all values from all available selectors (even if added later)\n\n\n    store.selectAll = function () {\n      return store.select(Object.keys(store.meta.unboundSelectors));\n    }; // add support for dispatching an action by name\n\n\n    store.action = function (name, args) {\n      return store[name].apply(store, args);\n    }; // adds support for subscribing to changes from an array of selector strings\n\n\n    addBindingMethods(store); // add all the gathered bundle data into the store\n\n    decorateStore(store, firstChunk); // defines method for integrating other bundles later\n\n    store.integrateBundles = function () {\n      var bundlesToIntegrate = [],\n          len = arguments.length;\n\n      while (len--) bundlesToIntegrate[len] = arguments[len];\n\n      decorateStore(store, createChunk(bundlesToIntegrate));\n      var allReducers = store.meta.chunks.reduce(function (accum, chunk) {\n        return Object.assign(accum, chunk.reducers);\n      }, {});\n      store.replaceReducer(enhanceReducer(combineReducers(allReducers)));\n    };\n\n    return store;\n  };\n}; // regexes borrowed from backbone\n\n\nvar optionalParam = /\\((.*?)\\)/g;\nvar namedParam = /(\\(\\?)?:\\w+/g;\nvar escapeRegExp = /[\\-{}\\[\\]+?.,\\\\\\^$|#\\s]/g;\nvar splatParam = /\\*/g; // Parses a URL pattern such as `/users/:id`\n// and builds and returns a regex that can be used to\n// match said pattern. Credit for these\n// regexes belongs to Jeremy Ashkenas and the\n// other maintainers of Backbone.js\n//\n// It has been modified for extraction of\n// named paramaters from the URL\n\nvar parsePattern = function (pattern) {\n  var names = [];\n  pattern = pattern.replace(escapeRegExp, '\\\\$&').replace(optionalParam, '(?:$1)?').replace(namedParam, function (match, optional) {\n    names.push(match.slice(1));\n    return optional ? match : '([^/?]+)';\n  }).replace(splatParam, function (match, optional) {\n    names.push('path');\n    return '([^?]*?)';\n  });\n  return {\n    regExp: new RegExp('^' + pattern + '(?:\\\\?([\\\\s\\\\S]*))?$'),\n    namedParams: names\n  };\n};\n\nvar featherRouteMatcher = function (routes, fallback) {\n  var keys = Object.keys(routes); // loop through each route we're\n  // and build the shell of our\n  // route cache.\n\n  for (var item in routes) {\n    routes[item] = {\n      value: routes[item]\n    };\n  } // main result is a function that can be called\n  // with the url\n\n\n  return function (url) {\n    var params;\n    var route; // start looking for matches\n\n    var matchFound = keys.some(function (key) {\n      var parsed; // fetch the route pattern from the cache\n      // there will always be one\n\n      route = routes[key]; // if the route doesn't already have\n      // a regex we never generated one\n      // so we do that here lazily.\n      // Parse the pattern to generate the\n      // regex once, and store the result\n      // for next time.\n\n      if (!route.regExp) {\n        parsed = parsePattern(key);\n        route.regExp = parsed.regExp;\n        route.namedParams = parsed.namedParams;\n        route.pattern = key;\n      } // run our cached regex\n\n\n      var result = route.regExp.exec(url); // if null there was no match\n      // returning falsy here continues\n      // the `Array.prototype.some` loop\n\n      if (!result) {\n        return;\n      } // remove other cruft from result\n\n\n      result = result.slice(1, -1); // reduce our match to an object of named paramaters\n      // we've extracted from the url\n\n      params = result.reduce(function (obj, val, index) {\n        if (val) {\n          obj[route.namedParams[index]] = val;\n        }\n\n        return obj;\n      }, {}); // stops the loop\n\n      return true;\n    }); // no routes matched\n\n    if (!matchFound) {\n      if (fallback) {\n        return {\n          page: fallback,\n          url: url,\n          params: null\n        };\n      }\n\n      return null;\n    }\n\n    return {\n      page: route.value,\n      params: params,\n      url: url,\n      pattern: route.pattern\n    };\n  };\n};\n\nvar defaults = {\n  routeInfoSelector: 'selectPathname'\n};\n\nvar createRoutingBundle = function (routes, spec) {\n  var opts = Object.assign({}, defaults, spec);\n  var routeInfoSelector = opts.routeInfoSelector;\n  var routeMatcher = featherRouteMatcher(routes);\n  return {\n    name: 'routes',\n    selectRoutes: function () {\n      return routes;\n    },\n    selectRouteMatcher: function () {\n      return routeMatcher;\n    },\n    selectRouteInfo: createSelector$1(routeInfoSelector, routeMatcher),\n    selectRouteParams: createSelector$1('selectRouteInfo', function (ref) {\n      var params = ref.params;\n      return params;\n    }),\n    selectRoute: createSelector$1('selectRouteInfo', function (ref) {\n      var page = ref.page;\n      return page;\n    })\n  };\n};\n\nvar defaultOpts = {\n  actionBaseType: null,\n  staleAfter: 900000,\n  // fifteen minutes\n  retryAfter: 60000,\n  // one minute,\n  expireAfter: Infinity,\n  checkIfOnline: true,\n  persist: true\n};\n\nvar createAsyncResourceBundle = function (spec) {\n  var opts = Object.assign({}, defaultOpts, spec);\n\n  if (process.env.NODE_ENV !== 'production') {\n    var requiredOptions = ['name', 'getPromise'];\n    requiredOptions.forEach(function (requiredOption) {\n      if (!opts[requiredOption]) {\n        throw Error(\"You must supply a \" + requiredOption + \" option when creating a resource bundle.\");\n      }\n    });\n  }\n\n  var name = opts.name;\n  var staleAfter = opts.staleAfter;\n  var retryAfter = opts.retryAfter;\n  var actionBaseType = opts.actionBaseType;\n  var checkIfOnline = opts.checkIfOnline;\n  var expireAfter = opts.expireAfter;\n  var uCaseName = name.charAt(0).toUpperCase() + name.slice(1);\n  var baseType = actionBaseType || name.toUpperCase(); // build selectors\n\n  var inputSelectorName = \"select\" + uCaseName + \"Raw\";\n  var dataSelectorName = \"select\" + uCaseName;\n  var lastSuccessSelectorName = \"select\" + uCaseName + \"LastSuccess\";\n  var isExpiredSelectorName = \"select\" + uCaseName + \"IsExpired\";\n  var lastErrorSelectorName = \"select\" + uCaseName + \"LastError\";\n  var isStaleSelectorName = \"select\" + uCaseName + \"IsStale\";\n  var isWaitingToRetrySelectorName = \"select\" + uCaseName + \"IsWaitingToRetry\";\n  var isLoadingSelectorName = \"select\" + uCaseName + \"IsLoading\";\n  var failedPermanentlySelectorName = \"select\" + uCaseName + \"FailedPermanently\";\n  var shouldUpdateSelectorName = \"select\" + uCaseName + \"ShouldUpdate\"; // action types\n\n  var actions = {\n    STARTED: baseType + \"_FETCH_STARTED\",\n    FINISHED: baseType + \"_FETCH_FINISHED\",\n    FAILED: baseType + \"_FETCH_FAILED\",\n    CLEARED: baseType + \"_CLEARED\",\n    OUTDATED: baseType + \"_OUTDATED\",\n    EXPIRED: baseType + \"_EXPIRED\" // action creators\n\n  };\n\n  var doFetchError = function (error) {\n    return {\n      type: actions.FAILED,\n      error: error\n    };\n  };\n\n  var doMarkAsOutdated = function () {\n    return {\n      type: actions.OUTDATED\n    };\n  };\n\n  var doClear = function () {\n    return {\n      type: actions.CLEARED\n    };\n  };\n\n  var doExpire = function () {\n    return {\n      type: actions.EXPIRED\n    };\n  };\n\n  var doFetchSuccess = function (payload) {\n    return {\n      type: actions.FINISHED,\n      payload: payload\n    };\n  };\n\n  var doFetchData = function () {\n    return function (args) {\n      var dispatch = args.dispatch;\n      dispatch({\n        type: actions.STARTED\n      });\n      return opts.getPromise(args).then(function (payload) {\n        dispatch(doFetchSuccess(payload));\n      }, function (error) {\n        dispatch(doFetchError(error));\n      });\n    };\n  };\n\n  var initialState = {\n    data: null,\n    errorTimes: [],\n    errorType: null,\n    lastSuccess: null,\n    isOutdated: false,\n    isLoading: false,\n    isExpired: false,\n    failedPermanently: false\n  };\n  var result = {\n    name: name,\n    reducer: function (state, ref) {\n      if (state === void 0) state = initialState;\n      var type = ref.type;\n      var payload = ref.payload;\n      var error = ref.error;\n      var merge = ref.merge;\n\n      if (type === actions.STARTED) {\n        return Object.assign({}, state, {\n          isLoading: true\n        });\n      }\n\n      if (type === actions.FINISHED) {\n        var updatedData;\n\n        if (merge) {\n          updatedData = Object.assign({}, state.data, payload);\n        } else {\n          updatedData = payload;\n        }\n\n        return Object.assign({}, state, {\n          isLoading: false,\n          data: updatedData,\n          lastSuccess: Date.now(),\n          errorTimes: [],\n          errorType: null,\n          failedPermanently: false,\n          isOutdated: false,\n          isExpired: false\n        });\n      }\n\n      if (type === actions.FAILED) {\n        var errorMessage = error && error.message || error;\n        return Object.assign({}, state, {\n          isLoading: false,\n          errorTimes: state.errorTimes.concat([Date.now()]),\n          errorType: errorMessage,\n          failedPermanently: !!(error && error.permanent)\n        });\n      }\n\n      if (type === actions.CLEARED) {\n        return initialState;\n      }\n\n      if (type === actions.EXPIRED) {\n        return Object.assign({}, initialState, {\n          isExpired: true,\n          errorTimes: state.errorTimes,\n          errorType: state.errorType\n        });\n      }\n\n      if (type === actions.OUTDATED) {\n        return Object.assign({}, state, {\n          isOutdated: true\n        });\n      }\n\n      return state;\n    }\n  };\n\n  result[inputSelectorName] = function (state) {\n    return state[name];\n  };\n\n  result[dataSelectorName] = createSelector$1(inputSelectorName, function (root) {\n    return root.data;\n  });\n  result[isStaleSelectorName] = createSelector$1(inputSelectorName, lastSuccessSelectorName, 'selectAppTime', function (state, time, appTime) {\n    if (state.isOutdated) {\n      return true;\n    }\n\n    if (!time) {\n      return false;\n    }\n\n    return appTime - time > staleAfter;\n  });\n  result[isExpiredSelectorName] = createSelector$1(inputSelectorName, function (root) {\n    return root.isExpired;\n  });\n  result[lastErrorSelectorName] = createSelector$1(inputSelectorName, function (resource) {\n    return resource.errorTimes.slice(-1)[0] || null;\n  });\n  result[lastSuccessSelectorName] = createSelector$1(inputSelectorName, function (root) {\n    return root.lastSuccess;\n  });\n  result[isWaitingToRetrySelectorName] = createSelector$1(lastErrorSelectorName, 'selectAppTime', function (time, appTime) {\n    if (!time) {\n      return false;\n    }\n\n    return appTime - time < retryAfter;\n  });\n  result[isLoadingSelectorName] = createSelector$1(inputSelectorName, function (resourceState) {\n    return resourceState.isLoading;\n  });\n  result[failedPermanentlySelectorName] = createSelector$1(inputSelectorName, function (resourceState) {\n    return resourceState.failedPermanently;\n  });\n  result[shouldUpdateSelectorName] = createSelector$1(isLoadingSelectorName, failedPermanentlySelectorName, isWaitingToRetrySelectorName, dataSelectorName, isStaleSelectorName, 'selectIsOnline', function (isLoading, failedPermanently, isWaitingToRetry, data, isStale, isOnline) {\n    if (checkIfOnline && !isOnline || isLoading || failedPermanently || isWaitingToRetry) {\n      return false;\n    }\n\n    if (data === null) {\n      return true;\n    }\n\n    return isStale;\n  });\n  result[\"doFetch\" + uCaseName] = doFetchData;\n  result[\"doMark\" + uCaseName + \"AsOutdated\"] = doMarkAsOutdated;\n  result[\"doClear\" + uCaseName] = doClear;\n  result[\"doExpire\" + uCaseName] = doExpire;\n\n  if (opts.persist) {\n    result.persistActions = [actions.FINISHED, actions.EXPIRED, actions.OUTDATED, actions.CLEARED];\n  }\n\n  if (expireAfter !== Infinity) {\n    result[\"reactExpire\" + uCaseName] = createSelector$1(lastSuccessSelectorName, 'selectAppTime', function (time, appTime) {\n      if (!time) {\n        return false;\n      }\n\n      if (appTime - time > expireAfter) {\n        return doExpire();\n      }\n    });\n  }\n\n  return result;\n};\n\nvar e = !(\"undefined\" == typeof window && \"undefined\" == typeof self),\n    n = \"undefined\" == typeof requestIdleCallback ? function (e) {\n  return setTimeout(e, 0);\n} : requestIdleCallback;\n\nfunction getPersistMiddleware(t) {\n  var u = t.cacheFn,\n      r = t.actionMap,\n      o = t.logger;\n  return function (t) {\n    var i = t.getState;\n    return function (t) {\n      return function (a) {\n        var f = r[a.type],\n            c = t(a),\n            d = i();\n        return e && f && n(function () {\n          Promise.all(f.map(function (e) {\n            return u(e, d[e]);\n          })).then(function () {\n            o && o(\"cached \" + f.join(\", \") + \" due to \" + a.type);\n          });\n        }, {\n          timeout: 500\n        }), c;\n      };\n    };\n  };\n}\n\nvar caching = function (cacheFn) {\n  return {\n    name: 'localCache',\n    getMiddleware: function (chunk) {\n      var actionMap = {};\n      chunk.rawBundles.forEach(function (bundle) {\n        if (bundle.persistActions) {\n          bundle.persistActions.forEach(function (type) {\n            actionMap[type] || (actionMap[type] = []);\n            actionMap[type].push(bundle.name);\n          });\n        }\n      });\n      return getPersistMiddleware({\n        actionMap: actionMap,\n        cacheFn: cacheFn\n      });\n    }\n  };\n};\n\nvar getError = function (message, permanent) {\n  if (permanent === void 0) permanent = false;\n  var err = new Error(message);\n\n  if (permanent) {\n    err.permanent = true;\n  }\n\n  return err;\n};\n\nvar geoErrorArray = ['An unknown geolocation error occured', 'Geolocation permission denied', 'Geolocation unavailable', 'Geolocation request timed out'];\nvar defaultOpts$1 = {\n  timeout: 60000,\n  enableHighAccuracy: false,\n  persist: true,\n  staleAfter: 900000,\n  // fifteen minutes\n  retryAfter: 60000 // one minute,\n\n};\n\nvar geolocation = function (spec) {\n  var opts = Object.assign({}, defaultOpts$1, spec);\n  return createAsyncResourceBundle({\n    name: 'geolocation',\n    actionBaseType: 'GEOLOCATION_REQUEST',\n    getPromise: function () {\n      return new Promise(function (resolve, reject) {\n        if (!IS_BROWSER || !navigator.geolocation) {\n          reject(getError('Geolocation not supported', true));\n        }\n\n        var success = function (position) {\n          var res = {};\n          var coords = position.coords;\n\n          for (var key in coords) {\n            res[key] = coords[key];\n          }\n\n          res.timestamp = position.timestamp;\n          resolve(res);\n        };\n\n        var fail = function (ref) {\n          var code = ref.code;\n          reject(getError(geoErrorArray[code], code === 1));\n        };\n\n        var geoOpts = {\n          timeout: opts.timeout,\n          enableHighAccuracy: opts.enableHighAccuracy\n        };\n        navigator.geolocation.getCurrentPosition(success, fail, geoOpts);\n      });\n    },\n    persist: opts.persist,\n    staleAfter: opts.staleAfter,\n    retryAfter: opts.retryAfter\n  });\n};\n\nvar defaults$1 = {\n  idleTimeout: 30000,\n  idleAction: 'APP_IDLE',\n  doneCallback: null,\n  stopWhenTabInactive: true,\n  cancelIdleWhenDone: true\n};\nvar ricOptions = {\n  timeout: 500\n};\n\nvar getIdleDispatcher = function (stopWhenInactive, timeout, fn) {\n  return debounce(function () {\n    // the requestAnimationFrame ensures it doesn't run when tab isn't active\n    stopWhenInactive ? raf(function () {\n      return ric(fn, ricOptions);\n    }) : ric(fn, ricOptions);\n  }, timeout);\n};\n\nvar reactors = function (spec) {\n  return {\n    name: 'reactors',\n    init: function (store) {\n      var ref = Object.assign({}, defaults$1, spec);\n      var idleAction = ref.idleAction;\n      var idleTimeout = ref.idleTimeout;\n      var cancelIdleWhenDone = ref.cancelIdleWhenDone;\n      var doneCallback = ref.doneCallback;\n      var stopWhenTabInactive = ref.stopWhenTabInactive;\n      var idleDispatcher;\n\n      if (idleTimeout) {\n        idleDispatcher = getIdleDispatcher(stopWhenTabInactive, idleTimeout, function () {\n          return store.dispatch({\n            type: idleAction\n          });\n        });\n      }\n\n      if (process.env.NODE_ENV !== 'production') {\n        store.meta.reactorNames.forEach(function (name) {\n          if (!store[name]) {\n            throw Error(\"Reactor '\" + name + \"' not found on the store. Make sure you're defining as selector by that name.\");\n          }\n        });\n      }\n\n      var cancelIfDone = function () {\n        if (!IS_BROWSER && !store.nextReaction && (!store.selectAsyncActive || !store.selectAsyncActive())) {\n          idleDispatcher && idleDispatcher.cancel();\n          doneCallback && doneCallback();\n        }\n      };\n\n      var dispatchNext = function () {\n        // one at a time\n        if (store.nextReaction) {\n          return;\n        } // look for the next one\n\n\n        store.meta.reactorNames.some(function (name) {\n          var result = store[name]();\n\n          if (result) {\n            store.activeReactor = name;\n            store.nextReaction = result;\n          }\n\n          return result;\n        });\n\n        if (store.nextReaction) {\n          // let browser chill\n          ric(function () {\n            var nextReaction = store.nextReaction;\n            store.activeReactor = null;\n            store.nextReaction = null;\n            store.dispatch(nextReaction);\n          }, ricOptions);\n        }\n      };\n\n      var callback = function () {\n        dispatchNext();\n\n        if (idleDispatcher) {\n          idleDispatcher();\n          cancelIdleWhenDone && cancelIfDone();\n        }\n      };\n\n      store.subscribe(callback);\n      callback();\n    }\n  };\n};\n\nvar has = Object.prototype.hasOwnProperty;\n/**\n * Simple query string parser.\n *\n * @param {String} query The query string that needs to be parsed.\n * @returns {Object}\n * @api public\n */\n\nfunction querystring(query) {\n  var parser = /([^=?&]+)=?([^&]*)/g,\n      result = {},\n      part; //\n  // Little nifty parsing hack, leverage the fact that RegExp.exec increments\n  // the lastIndex property so we can continue executing this loop until we've\n  // parsed all results.\n  //\n\n  for (; part = parser.exec(query); result[decodeURIComponent(part[1])] = decodeURIComponent(part[2]));\n\n  return result;\n}\n/**\n * Transform a query string to an object.\n *\n * @param {Object} obj Object that should be transformed.\n * @param {String} prefix Optional prefix.\n * @returns {String}\n * @api public\n */\n\n\nfunction querystringify(obj, prefix) {\n  prefix = prefix || '';\n  var pairs = []; //\n  // Optionally prefix with a '?' if needed\n  //\n\n  if ('string' !== typeof prefix) prefix = '?';\n\n  for (var key in obj) {\n    if (has.call(obj, key)) {\n      pairs.push(encodeURIComponent(key) + '=' + encodeURIComponent(obj[key]));\n    }\n  }\n\n  return pairs.length ? prefix + pairs.join('&') : '';\n} //\n// Expose the module.\n//\n\n\nvar stringify = querystringify;\nvar parse = querystring;\nvar querystringify_1 = {\n  stringify: stringify,\n  parse: parse\n};\n\nvar isString = function (obj) {\n  return Object.prototype.toString.call(obj) === '[object String]';\n};\n\nvar isDefined = function (thing) {\n  return typeof thing !== 'undefined';\n};\n\nvar ensureString = function (input) {\n  return isString(input) ? input : querystringify_1.stringify(input);\n};\n\nvar IPRE = /^[0-9.]+$/;\n\nvar parseSubdomains = function (hostname, getBareHost) {\n  if (IPRE.test(hostname)) {\n    return [];\n  }\n\n  var parts = hostname.split('.');\n\n  if (getBareHost) {\n    return parts.slice(-2).join('.');\n  }\n\n  return hostname.split('.').slice(0, -2);\n};\n\nvar removeLeading = function (char, string) {\n  return string.charAt(0) === char ? string.slice(1) : string;\n};\n\nvar ensureLeading = function (char, string) {\n  if (string === char || string === '') {\n    return '';\n  }\n\n  return string.charAt(0) !== char ? char + string : string;\n};\n\nvar loc = function () {\n  if (!HAS_WINDOW) {\n    return {};\n  }\n\n  return window.location;\n}();\n\nvar defaults$2 = {\n  name: 'url',\n  inert: !HAS_WINDOW,\n  actionType: 'URL_UPDATED',\n  handleScrollRestoration: true\n};\n\nvar makeSerializable = function (url) {\n  var result = {};\n\n  for (var key in url) {\n    var val = url[key];\n\n    if (isString(val)) {\n      result[key] = val;\n    }\n  }\n\n  return result;\n};\n\nvar url = function (opts) {\n  var config = Object.assign({}, defaults$2, opts);\n  var actionType = config.actionType;\n\n  var selectUrlRaw = function (state) {\n    return state[config.name];\n  };\n\n  var selectUrlObject = createSelector$1(selectUrlRaw, function (urlState) {\n    return makeSerializable(new URL(urlState.url));\n  });\n  var selectQueryObject = createSelector$1(selectUrlObject, function (urlObj) {\n    return querystringify_1.parse(urlObj.search);\n  });\n  var selectQueryString = createSelector$1(selectQueryObject, function (queryObj) {\n    return querystringify_1.stringify(queryObj);\n  });\n  var selectPathname = createSelector$1(selectUrlObject, function (urlObj) {\n    return urlObj.pathname;\n  });\n  var selectHash = createSelector$1(selectUrlObject, function (urlObj) {\n    return removeLeading('#', urlObj.hash);\n  });\n  var selectHashObject = createSelector$1(selectHash, function (hash) {\n    return querystringify_1.parse(hash);\n  });\n  var selectHostname = createSelector$1(selectUrlObject, function (urlObj) {\n    return urlObj.hostname;\n  });\n  var selectSubdomains = createSelector$1(selectHostname, function (hostname) {\n    return parseSubdomains(hostname);\n  });\n\n  var doUpdateUrl = function (newState, opts) {\n    if (opts === void 0) opts = {\n      replace: false,\n      maintainScrollPosition: false\n    };\n    return function (ref) {\n      var dispatch = ref.dispatch;\n      var getState = ref.getState;\n      var state = newState;\n\n      if (typeof newState === 'string') {\n        var parsed = new URL(newState.charAt(0) === '/' ? 'http://example.com' + newState : newState);\n        state = {\n          pathname: parsed.pathname,\n          query: parsed.search || '',\n          hash: parsed.hash || ''\n        };\n      }\n\n      var url = new URL(selectUrlRaw(getState()).url);\n\n      if (isDefined(state.pathname)) {\n        url.pathname = state.pathname;\n      }\n\n      if (isDefined(state.hash)) {\n        url.hash = ensureString(state.hash);\n      }\n\n      if (isDefined(state.query)) {\n        url.search = ensureString(state.query);\n      }\n\n      dispatch({\n        type: actionType,\n        payload: {\n          url: url.href,\n          replace: opts.replace,\n          maintainScrollPosition: opts.maintainScrollPosition\n        }\n      });\n    };\n  };\n\n  var doReplaceUrl = function (url) {\n    return doUpdateUrl(url, {\n      replace: true\n    });\n  };\n\n  var doUpdateQuery = function (query, opts) {\n    if (opts === void 0) opts = {\n      replace: true\n    };\n    return doUpdateUrl({\n      query: ensureString(query)\n    }, opts);\n  };\n\n  var doUpdateHash = function (hash, opts) {\n    if (opts === void 0) opts = {\n      replace: false\n    };\n    return doUpdateUrl({\n      hash: ensureLeading('#', ensureString(hash))\n    }, opts);\n  };\n\n  return {\n    name: config.name,\n    init: function (store) {\n      if (config.inert) {\n        return;\n      }\n\n      if (config.handleScrollRestoration) {\n        initScrollPosition();\n      }\n\n      window.addEventListener('popstate', function () {\n        store.doUpdateUrl({\n          pathname: loc.pathname,\n          hash: loc.hash,\n          query: loc.search\n        });\n      });\n      var lastState = store.selectUrlRaw();\n      store.subscribe(function () {\n        var newState = store.selectUrlRaw();\n        var newUrl = newState.url;\n\n        if (lastState !== newState && newUrl !== loc.href) {\n          try {\n            window.history[newState.replace ? 'replaceState' : 'pushState']({}, null, newState.url);\n\n            if (config.handleScrollRestoration) {\n              saveScrollPosition();\n            }\n\n            if (!newState.maintainScrollPosition) {\n              window.scrollTo(0, 0);\n            }\n          } catch (e) {\n            console.error(e);\n          }\n        }\n\n        lastState = newState;\n      });\n    },\n    getReducer: function () {\n      var initialState = {\n        url: !config.inert && HAS_WINDOW ? loc.href : '/',\n        replace: false,\n        maintainScrollPosition: false\n      };\n      return function (state, ref) {\n        if (state === void 0) state = initialState;\n        var type = ref.type;\n        var payload = ref.payload;\n\n        if (typeof state === 'string') {\n          return {\n            url: state,\n            replace: false,\n            maintainScrollPosition: false\n          };\n        }\n\n        if (type === actionType) {\n          return Object.assign({\n            url: payload.url || payload,\n            replace: !!payload.replace,\n            maintainScrollPosition: !!payload.maintainScrollPosition\n          });\n        }\n\n        return state;\n      };\n    },\n    doUpdateUrl: doUpdateUrl,\n    doReplaceUrl: doReplaceUrl,\n    doUpdateQuery: doUpdateQuery,\n    doUpdateHash: doUpdateHash,\n    selectUrlRaw: selectUrlRaw,\n    selectUrlObject: selectUrlObject,\n    selectQueryObject: selectQueryObject,\n    selectQueryString: selectQueryString,\n    selectPathname: selectPathname,\n    selectHash: selectHash,\n    selectHashObject: selectHashObject,\n    selectHostname: selectHostname,\n    selectSubdomains: selectSubdomains\n  };\n};\n\nvar debugMiddleware = function (store) {\n  return function (next) {\n    return function (action) {\n      var isDebug = store.getState().debug;\n\n      if (isDebug) {\n        console.group(action.type);\n        console.info('action:', action);\n      }\n\n      var result = next(action);\n\n      if (isDebug) {\n        console.debug('state:', store.getState());\n        self.logSelectors && self.logSelectors();\n        self.logNextReaction && self.logNextReaction();\n        console.groupEnd(action.type);\n      }\n\n      return result;\n    };\n  };\n}; // import { version } from '../../package.json'\n\n\nvar ENABLE = 'DEBUG_ENABLED';\nvar DISABLE = 'DEBUG_DISABLED';\nvar debug$1 = {\n  name: 'debug',\n  reducer: function (state, ref) {\n    if (state === void 0) state = HAS_DEBUG_FLAG;\n    var type = ref.type;\n\n    if (type === ENABLE) {\n      return true;\n    }\n\n    if (type === DISABLE) {\n      return false;\n    }\n\n    return state;\n  },\n  doEnableDebug: function () {\n    return {\n      type: ENABLE\n    };\n  },\n  doDisableDebug: function () {\n    return {\n      type: DISABLE\n    };\n  },\n  selectIsDebug: function (state) {\n    return state.debug;\n  },\n  getMiddleware: function () {\n    return debugMiddleware;\n  },\n  init: function (store) {\n    if (store.selectIsDebug()) {\n      var names = store.meta.chunks[0].bundleNames;\n      self.store = store;\n      var actionCreators = [];\n\n      for (var key in store) {\n        if (key.indexOf('do') === 0) {\n          actionCreators.push(key);\n        }\n      }\n\n      actionCreators.sort();\n      var colorTitle = 'color: #1676D2;';\n      var black = 'color: black;';\n      var colorGreen = 'color: #4CAF50;';\n      var colorOrange = 'color: #F57C00;';\n\n      store.logSelectors = self.logSelectors = function () {\n        if (!store.selectAll) {\n          return;\n        }\n\n        console.log('%cselectors:', colorGreen, store.selectAll());\n      };\n\n      store.logBundles = self.logBundles = function () {\n        console.log('%cinstalled bundles:\\n  %c%s', colorTitle, black, names.join('\\n  '));\n      };\n\n      store.logActionCreators = self.logActionCreators = function () {\n        console.groupCollapsed('%caction creators', colorOrange);\n        actionCreators.forEach(function (name) {\n          return console.log(name);\n        });\n        console.groupEnd();\n      };\n\n      store.logReactors = self.logReactors = function () {\n        console.groupCollapsed('%creactors', colorOrange);\n        var ref = store.meta;\n        var reactorNames = ref.reactorNames;\n        reactorNames.forEach(function (name) {\n          return console.log(name);\n        });\n        console.groupEnd();\n      };\n\n      store.logNextReaction = self.logNextReaction = function () {\n        var nextReaction = store.nextReaction;\n        var activeReactor = store.activeReactor;\n\n        if (nextReaction) {\n          console.log(\"%cnext reaction:\\n  %c\" + activeReactor, colorOrange, black, nextReaction);\n        }\n      };\n\n      console.groupCollapsed('%credux bundler', colorTitle);\n      store.logBundles();\n      store.logSelectors();\n      store.logReactors();\n      console.groupEnd();\n\n      if (store.isReacting) {\n        console.log(\"%cqueuing reaction:\", colorOrange);\n      }\n    }\n  }\n};\nvar OFFLINE = 'OFFLINE';\nvar ONLINE = 'ONLINE';\nvar online = {\n  name: 'online',\n  selectIsOnline: function (state) {\n    return state.online;\n  },\n  getReducer: function () {\n    var initialState = IS_BROWSER ? navigator.onLine : true;\n    return function (state, ref) {\n      if (state === void 0) state = initialState;\n      var type = ref.type;\n\n      if (type === OFFLINE) {\n        return false;\n      }\n\n      if (type === ONLINE) {\n        return true;\n      }\n\n      return state;\n    };\n  },\n  init: function (store) {\n    addGlobalListener('online', function () {\n      return store.dispatch({\n        type: ONLINE\n      });\n    });\n    addGlobalListener('offline', function () {\n      return store.dispatch({\n        type: OFFLINE\n      });\n    });\n  }\n};\nvar appTimeBundle = appTime;\nvar asyncCountBundle = asyncCount;\nvar createCacheBundle = caching;\nvar createRouteBundle = createRoutingBundle;\nvar createAsyncResourceBundle$1 = createAsyncResourceBundle;\nvar createReactorBundle = reactors;\nvar getIdleDispatcher$1 = getIdleDispatcher;\nvar onlineBundle = online;\nvar createUrlBundle = url;\nvar debugBundle = debug$1;\nvar composeBundlesRaw = composeBundles;\nvar createGeolocationBundle = geolocation;\n\nvar composeBundles$1 = function () {\n  var userBundles = [],\n      len = arguments.length;\n\n  while (len--) userBundles[len] = arguments[len];\n\n  userBundles || (userBundles = []);\n  var bundles = [appTime, asyncCount, online, url(), reactors(), debug$1].concat(userBundles);\n  return composeBundles.apply(void 0, bundles);\n};\n\nexport { appTimeBundle, asyncCountBundle, createCacheBundle, createRouteBundle, createAsyncResourceBundle$1 as createAsyncResourceBundle, createReactorBundle, getIdleDispatcher$1 as getIdleDispatcher, onlineBundle, createUrlBundle, debugBundle, composeBundlesRaw, createGeolocationBundle, composeBundles$1 as composeBundles, createSelector$1 as createSelector, resolveSelectors, HAS_DEBUG_FLAG, HAS_WINDOW, IS_BROWSER, IS_PROD, raf, ric, isPassiveSupported, PASSIVE_EVENTS_SUPPORTED, startsWith, flattenExtractedToObject, flattenExtractedToArray, addGlobalListener, selectorNameToValueName, debounce, saveScrollPosition, restoreScrollPosition, initScrollPosition, createStore, combineReducers, bindActionCreators, applyMiddleware, compose, ActionTypes as __DO_NOT_USE__ActionTypes };","map":null,"metadata":{},"sourceType":"module"}