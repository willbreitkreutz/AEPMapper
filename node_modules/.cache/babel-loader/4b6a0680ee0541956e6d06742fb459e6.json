{"ast":null,"code":"import Collection from 'ol/Collection';\nimport XYZ from 'ol/source/XYZ';\nimport TileArcGISRest from 'ol/source/TileArcGISRest';\nimport ImageArcGISRest from 'ol/source/ImageArcGISRest';\nimport ImageWMS from 'ol/source/ImageWMS';\nimport VectorSrc from 'ol/source/Vector';\nimport Tile from 'ol/layer/Tile';\nimport Image from 'ol/layer/Image';\nimport Vector from 'ol/layer/Vector';\nimport GeoJSON from 'ol/format/GeoJSON';\nimport vectorStyleCreator from './vector-style';\nimport xhr from 'xhr';\nimport EsriJSON from 'ol/format/EsriJSON.js';\nimport { tile } from 'ol/loadingstrategy';\nimport { createXYZ } from 'ol/tilegrid';\nconst esrijsonFormat = new EsriJSON();\nconst origin = window.location.origin;\n\nconst isCrossOrigin = url => {\n  if (!!window.MSInputMethodContext && !!document.documentMode) return null;\n\n  if (url) {\n    if (url.indexOf(origin) === -1) return 'anonymous';\n  } else {\n    return null;\n  }\n};\n\nfunction formatLabeledUrl(url) {\n  const delim = url.indexOf('?') === -1 ? '?' : '&';\n  return \"\".concat(url).concat(delim, \"label=true\");\n}\n\nfunction getXyzSource(options) {\n  const labelsOn = !!options.labelDefault;\n  const url = labelsOn ? formatLabeledUrl(options.url) : options.url;\n  return new XYZ({\n    url: url,\n    crossOrigin: isCrossOrigin(options.url)\n  });\n}\n\nfunction getArcGISTiledSource(options) {\n  return new TileArcGISRest({\n    url: options.url,\n    params: {\n      LAYERS: 'show:' + options.layerList\n    },\n    crossOrigin: isCrossOrigin(options.url)\n  });\n}\n\nfunction getArcGISImageSource(options) {\n  return new ImageArcGISRest({\n    url: options.url,\n    crossOrigin: isCrossOrigin(options.url)\n  });\n}\n\nfunction getWmsSource(options) {\n  const params = options.params || options;\n  params.LAYERS = options.layerList || options.LAYERS;\n  return new ImageWMS({\n    url: options.url,\n    params: params,\n    crossOrigin: isCrossOrigin(options.url)\n  });\n}\n\nfunction getLocalVectorSource(options) {\n  return new VectorSrc({\n    features: options.features || new Collection()\n  });\n}\n\nfunction getRemoteVectorSource(options) {\n  const src = new VectorSrc({\n    format: new GeoJSON(),\n    url: options.url\n  });\n  src.on('addfeature', e => {\n    const uid = options.uid;\n    const g = new GeoJSON();\n    const geojson = g.writeFeatureObject(e.feature, {\n      featureProjection: 'EPSG:3857',\n      dataProjection: 'EPSG:4326'\n    });\n  });\n  return src;\n}\n\nfunction getEsriVectorSource(options) {\n  let serviceUrl = options.url;\n  const layer = options.layerList;\n  const trailingSlashMatch = /\\/$/;\n  if (!trailingSlashMatch.test(serviceUrl)) serviceUrl += '/';\n  const src = new VectorSrc({\n    loader: function (extent, resolution, projection) {\n      const g = encodeURIComponent(\"{\\\"xmin\\\":\".concat(extent[0], \",\\\"ymin\\\":\").concat(extent[1], \",\\\"xmax\\\":\").concat(extent[2], \",\\\"ymax\\\":\").concat(extent[3], \",\\\"spatialReference\\\":{\\\"wkid\\\":102100}}\"));\n      const url = \"\".concat(serviceUrl).concat(layer, \"/query/?f=json&returnGeometry=true&spatialRel=esriSpatialRelIntersects&geometry=\").concat(g, \"&geometryType=esriGeometryEnvelope&inSR=102100&outFields=*&outSR=102100\");\n      xhr.get(url, (err, response, body) => {\n        if (err) return console.log(err);\n        const data = JSON.parse(body);\n        const features = esrijsonFormat.readFeatures(data, {\n          featureProjection: projection\n        });\n\n        if (features.length > 0) {\n          src.addFeatures(features);\n        }\n      });\n    },\n    strategy: tile(createXYZ({\n      tileSize: 512\n    }))\n  });\n  return src;\n}\n\nfunction getTileLayer(options, source) {\n  return new Tile({\n    source: source,\n    visible: options.visible,\n    zIndex: options.zIndex || 0,\n    opacity: options.opacity || 1,\n    minResolution: options.minResolution || undefined,\n    maxResolution: options.maxResolution || undefined\n  });\n}\n\nfunction getImageLayer(options, source) {\n  return new Image({\n    source: source,\n    visible: options.visible,\n    zIndex: options.zIndex || 0,\n    opacity: options.opacity || 1,\n    minResolution: options.minResolution || undefined,\n    maxResolution: options.maxResolution || undefined\n  });\n}\n\nfunction getLocalVectorLayer(options, source) {\n  return new Vector({\n    altitudeMode: 'clampToGround',\n    source: source,\n    visible: options.visible,\n    style: vectorStyleCreator(options),\n    zIndex: options.zIndex || 0,\n    opacity: options.opacity || 1,\n    minResolution: options.minResolution || undefined,\n    maxResolution: options.maxResolution || undefined\n  });\n}\n\nfunction getRemoteVectorLayer(options, source) {\n  const lyr = new Vector({\n    altitudeMode: 'clampToGround',\n    source: source,\n    visible: options.visible,\n    style: vectorStyleCreator(options),\n    zIndex: options.zIndex || 0,\n    opacity: options.opacity || 1,\n    renderMode: 'image',\n    minResolution: options.minResolution || undefined,\n    maxResolution: options.maxResolution || undefined\n  });\n  const uid = options.uid;\n  return lyr;\n}\n\nfunction getEsriVectorLayer(options, source) {\n  const lyr = new Vector({\n    altitudeMode: 'clampToGround',\n    source: source,\n    visible: options.visible,\n    style: vectorStyleCreator(options),\n    zIndex: options.zIndex || 0,\n    opacity: options.opacity || 1,\n    renderMode: 'image',\n    minResolution: options.minResolution || undefined,\n    maxResolution: options.maxResolution || undefined\n  });\n  return lyr;\n}\n\nfunction getSource(options) {\n  switch (options.serviceType) {\n    case 'XYZ':\n      return getXyzSource(options);\n\n    case 'ArcGIS':\n      return getArcGISTiledSource(options);\n\n    case 'ArcGISImage':\n      return getArcGISImageSource(options);\n\n    case 'WMS':\n      return getWmsSource(options);\n\n    case 'LocalVector':\n      return getLocalVectorSource(options);\n\n    case 'RemoteVector':\n      return getRemoteVectorSource(options);\n\n    case 'EsriFeatureService':\n      return getEsriVectorSource(options);\n\n    default:\n      return null;\n  }\n}\n\nfunction getLayer(options, source) {\n  if (!source) source = getSource(options);\n\n  switch (options.serviceType) {\n    case 'XYZ':\n      return getTileLayer(options, source);\n\n    case 'ArcGIS':\n      return getTileLayer(options, source);\n\n    case 'ArcGISImage':\n      return getImageLayer(options, source);\n\n    case 'WMS':\n      return getImageLayer(options, source);\n\n    case 'LocalVector':\n      return getLocalVectorLayer(options, source);\n\n    case 'RemoteVector':\n      return getRemoteVectorLayer(options, source);\n\n    case 'EsriFeatureService':\n      return getEsriVectorLayer(options, source);\n\n    default:\n      return null;\n  }\n}\n\nexport { getSource, getLayer };","map":null,"metadata":{},"sourceType":"module"}